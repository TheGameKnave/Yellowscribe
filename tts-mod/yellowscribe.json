{
  "SaveName": "Yellowscribe",
  "EpochTime": 1632606895,
  "Date": "9/25/2021 2:54:55 PM",
  "VersionNumber": "v13.2.1",
  "GameMode": "Sandbox",
  "GameType": "",
  "GameComplexity": "",
  "Tags": [],
  "Gravity": 0.5,
  "PlayArea": 0.5,
  "Table": "Table_RPG",
  "Sky": "Sky_Regal",
  "Note": "",
  "TabStates": {
    "0": {
      "title": "Rules",
      "body": "",
      "color": "Grey",
      "visibleColor": {
        "r": 0.5,
        "g": 0.5,
        "b": 0.5
      },
      "id": 0
    },
    "1": {
      "title": "White",
      "body": "",
      "color": "White",
      "visibleColor": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0
      },
      "id": 1
    },
    "2": {
      "title": "Brown",
      "body": "",
      "color": "Brown",
      "visibleColor": {
        "r": 0.443,
        "g": 0.231,
        "b": 0.09
      },
      "id": 2
    },
    "3": {
      "title": "Red",
      "body": "",
      "color": "Red",
      "visibleColor": {
        "r": 0.856,
        "g": 0.1,
        "b": 0.094
      },
      "id": 3
    },
    "4": {
      "title": "Orange",
      "body": "",
      "color": "Orange",
      "visibleColor": {
        "r": 0.956,
        "g": 0.392,
        "b": 0.113
      },
      "id": 4
    },
    "5": {
      "title": "Yellow",
      "body": "",
      "color": "Yellow",
      "visibleColor": {
        "r": 0.905,
        "g": 0.898,
        "b": 0.172
      },
      "id": 5
    },
    "6": {
      "title": "Green",
      "body": "",
      "color": "Green",
      "visibleColor": {
        "r": 0.192,
        "g": 0.701,
        "b": 0.168
      },
      "id": 6
    },
    "7": {
      "title": "Blue",
      "body": "",
      "color": "Blue",
      "visibleColor": {
        "r": 0.118,
        "g": 0.53,
        "b": 1.0
      },
      "id": 7
    },
    "8": {
      "title": "Teal",
      "body": "",
      "color": "Teal",
      "visibleColor": {
        "r": 0.129,
        "g": 0.694,
        "b": 0.607
      },
      "id": 8
    },
    "9": {
      "title": "Purple",
      "body": "",
      "color": "Purple",
      "visibleColor": {
        "r": 0.627,
        "g": 0.125,
        "b": 0.941
      },
      "id": 9
    },
    "10": {
      "title": "Pink",
      "body": "",
      "color": "Pink",
      "visibleColor": {
        "r": 0.96,
        "g": 0.439,
        "b": 0.807
      },
      "id": 10
    },
    "11": {
      "title": "Black",
      "body": "",
      "color": "Black",
      "visibleColor": {
        "r": 0.25,
        "g": 0.25,
        "b": 0.25
      },
      "id": 11
    }
  },
  "Grid": {
    "Type": 0,
    "Lines": false,
    "Color": {
      "r": 0.0,
      "g": 0.0,
      "b": 0.0
    },
    "Opacity": 0.75,
    "ThickLines": false,
    "Snapping": false,
    "Offset": false,
    "BothSnapping": false,
    "xSize": 2.0,
    "ySize": 2.0,
    "PosOffset": {
      "x": 0.0,
      "y": 1.0,
      "z": 0.0
    }
  },
  "Lighting": {
    "LightIntensity": 0.54,
    "LightColor": {
      "r": 1.0,
      "g": 0.9804,
      "b": 0.8902
    },
    "AmbientIntensity": 1.3,
    "AmbientType": 0,
    "AmbientSkyColor": {
      "r": 0.5,
      "g": 0.5,
      "b": 0.5
    },
    "AmbientEquatorColor": {
      "r": 0.5,
      "g": 0.5,
      "b": 0.5
    },
    "AmbientGroundColor": {
      "r": 0.5,
      "g": 0.5,
      "b": 0.5
    },
    "ReflectionIntensity": 1.0,
    "LutIndex": 0,
    "LutContribution": 1.0
  },
  "Hands": {
    "Enable": true,
    "DisableUnused": false,
    "Hiding": 0
  },
  "ComponentTags": {
    "labels": [
      {
        "displayed": "captain",
        "normalized": "captain"
      },
      {
        "displayed": "uuid:49761312",
        "normalized": "uuid:49761312"
      },
      {
        "displayed": "leaderModel",
        "normalized": "leadermodel"
      },
      {
        "displayed": "uuid:34865cb8",
        "normalized": "uuid:34865cb8"
      },
      {
        "displayed": "uuid:76021708",
        "normalized": "uuid:76021708"
      },
      {
        "displayed": "uuid:7af0757b",
        "normalized": "uuid:7af0757b"
      },
      {
        "displayed": "uuid:4699a2b4",
        "normalized": "uuid:4699a2b4"
      },
      {
        "displayed": "wt:Gladiator Reaper",
        "normalized": "wt:gladiator_reaper"
      }
    ]
  },
  "Turns": {
    "Enable": false,
    "Type": 0,
    "TurnOrder": [],
    "Reverse": false,
    "SkipEmpty": false,
    "DisableInteractions": false,
    "PassTurns": true,
    "TurnColor": ""
  },
  "DecalPallet": [],
  "LuaScript": "Global.setVar(\"isYMBS2TTS\", true)",
  "LuaScriptState": "",
  "XmlUI": "<!-- Xml UI. See documentation: https://api.tabletopsimulator.com/ui/introUI/ -->",
  "ObjectStates": [
    {
      "GUID": "f33dff",
      "Name": "ScriptingTrigger",
      "Transform": {
        "posX": -42.497097,
        "posY": 3.51113486,
        "posZ": -2.78300071,
        "rotX": 0.0,
        "rotY": 359.6668,
        "rotZ": 0.0,
        "scaleX": 82.8436661,
        "scaleY": 21.07176,
        "scaleZ": 133.745026
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0,
        "a": 0.509803951
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "43ecc1",
      "Name": "BlockSquare",
      "Transform": {
        "posX": -0.838816464,
        "posY": 0.40041852,
        "posZ": 0.00218732632,
        "rotX": 9.252267E-06,
        "rotY": 359.944,
        "rotZ": -4.83700242E-05,
        "scaleX": 1.0,
        "scaleY": 1.0,
        "scaleZ": 1.0
      },
      "Nickname": "Yellow Storage",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 1.0,
        "g": 0.8141257,
        "b": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "LuaScript": "function none()\r\n\r\nend",
      "LuaScriptState": "",
      "XmlUI": "<!--\r\n    PLEASE NOTE:\r\n        there is no use of Defaults and classes here to enable easier backwards compatibility and\r\n        compatibility with other global UI. I hate the verbiosity just as much as the next person\r\n-->\r\n<Panel id=\"ym-container\" visibility=\"hidden\" group-id=\"\">\r\n    <VerticalLayout childForceExpandHeight=\"false\" childAlignment=\"TopLeft\" id=\"dataCard\" height=\"700\" width=\"1200\" color=\"#222222\" allowDragging=\"true\" returnToOriginalPositionWhenReleased=\"false\">\r\n        <Panel preferredHeight=\"40\" childForceExpandWidth=\"false\" color=\"#222222\">\r\n            <Text id=\"data-groupName\" fontStyle=\"Bold\" fontSize=\"26\" color=\"#fafafa\" alignment=\"MiddleCenter\" />\r\n            <Panel rectAlignment=\"UpperRight\" height=\"30\" width=\"30\">\r\n                <Button transition=\"None\" preferredHeight=\"24\" preferredWidth=\"24\" padding=\"3 3 3 3\" resizeTextForBestFit=\"true\" textAlignment=\"MiddleCenter\" height=\"30\" width=\"30\" color=\"#ffaa00\" textColor=\"#fafafa\" id=\"dataCardCloseButton\">X</Button>\r\n            </Panel>\r\n        </Panel>\r\n        <VerticalLayout color=\"#222222\">\r\n            <VerticalScrollView color=\"#222222\" flexibleHeight=\"1\" childForceExpandHeight=\"false\" scrollSensitivity=\"40\">\r\n                <VerticalLayout padding=\"10\" horizontalOverflow=\"Wrap\" spacing=\"30\" id=\"dataCardContentContainer\" childForceExpandHeight=\"false\" />\r\n            </VerticalScrollView>\r\n        </VerticalLayout>\r\n        <HorizontalLayout childForceExpandWidth=\"false\" childForceExpandHeight=\"false\" childAlignment=\"MiddleLeft\" color=\"#ffffff00\" spacing=\"3\" padding=\"7 0 0 0\" preferredHeight=\"27\" id=\"highlightButtonsContainer\" />\r\n    </VerticalLayout>\r\n</Panel>"
    },
    {
      "GUID": "46ccee",
      "Name": "BlockSquare",
      "Transform": {
        "posX": 0.161653131,
        "posY": 0.4004048,
        "posZ": -1.71980915E-07,
        "rotX": 7.42326E-05,
        "rotY": 0.000128269545,
        "rotZ": -0.000136235045,
        "scaleX": 1.0,
        "scaleY": 1.0,
        "scaleZ": 1.0
      },
      "Nickname": "Yellow Machine",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 1.0,
        "g": 0.8141257,
        "b": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": true,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "LuaScript": "-- Bundled by luabundle {\"rootModuleName\":\"Yellow Machine.46ccee.lua\",\"version\":\"1.6.0\"}\r\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\r\n\tlocal loadingPlaceholder = {[{}] = true}\r\n\r\n\tlocal register\r\n\tlocal modules = {}\r\n\r\n\tlocal require\r\n\tlocal loaded = {}\r\n\r\n\tregister = function(name, body)\r\n\t\tif not modules[name] then\r\n\t\t\tmodules[name] = body\r\n\t\tend\r\n\tend\r\n\r\n\trequire = function(name)\r\n\t\tlocal loadedModule = loaded[name]\r\n\r\n\t\tif loadedModule then\r\n\t\t\tif loadedModule == loadingPlaceholder then\r\n\t\t\t\treturn nil\r\n\t\t\tend\r\n\t\telse\r\n\t\t\tif not modules[name] then\r\n\t\t\t\tif not superRequire then\r\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\r\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\r\n\t\t\t\telse\r\n\t\t\t\t\treturn superRequire(name)\r\n\t\t\t\tend\r\n\t\t\tend\r\n\r\n\t\t\tloaded[name] = loadingPlaceholder\r\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\r\n\t\t\tloaded[name] = loadedModule\r\n\t\tend\r\n\r\n\t\treturn loadedModule\r\n\tend\r\n\r\n\treturn require, loaded, register, modules\r\nend)(nil)\r\n__bundle_register(\"Yellow Machine.46ccee.lua\", function(require, _LOADED, __bundle_register, __bundle_modules)\r\nrequire(\"vscode/console\")\r\n\r\nlocal DEBUG = true\r\n\r\nlocal loadedData, loadedDataOrder, originalLoadedOrder, edition, uiHeight, uiWidth, useDecorativeNames, armyDisplay, armyText\r\nlocal url = DEBUG and \"http://localhost:3000/get_army_by_id?id=\" or \"https://yellowscribe.xyz/get_army_by_id?id=\"\r\n\r\nlocal uiTemplates = {\r\n    UNIT_CONTAINER = [[ <VerticalLayout class=\"transparent\" childForceExpandHeight=\"false\">\r\n                            <Text class=\"groupName\">${groupName}</Text>\r\n                            <VerticalLayout class=\"groupContainer\" childForceExpandHeight=\"false\" preferredHeight=\"${height}\" spacing=\"20\">\r\n                                ${groupData}\r\n                            </VerticalLayout>\r\n                        </VerticalLayout> ]],\r\n    MODEL_CONTAINER = [[<VerticalLayout preferredWidth=\"500\" childForceExpandHeight=\"false\" class=\"gamePieceContainer\" id=\"${groupID}|${gamePieceID}\" preferredHeight=\"${height}\">\r\n                            <Text class=\"gamePieceDataName\">${numberString}${gamePieceName}</Text>\r\n                            ${weapons}\r\n                            ${abilities}\r\n                        </VerticalLayout> ]],\r\n    MODEL_DATA = [[ <VerticalLayout childForceExpandHeight=\"false\" childForceExpandWidth=\"false\">\r\n                        <Text height=\"15\"><!-- spacer --></Text>\r\n                        <Text class=\"gamePieceDataTitle\">${dataType}</Text>\r\n                        <Text class=\"gamePieceData\" preferredHeight=\"${height}\">${data}</Text>\r\n                    </VerticalLayout> ]],\r\n\r\n    MODEL_GROUPING_CONTAINER = [[ <HorizontalLayout class=\"groupingContainer\">${gamePieceGroups}</HorizontalLayout> ]]\r\n}\r\n\r\n--[[ UNIT SCRIPTING DATA ]]--\r\n--[[ everything in this section is meant to be a string because this is what we\r\nare inputting into created gamePieces ]]--\r\n\r\nlocal UNIT_SPECIFIC_DATA_TEMPLATE = [[ --[[ UNIT-SPECIFIC DATA ${endBracket}--\r\nlocal groupData = {\r\n    edition = \"${edition}\",\r\n    groupName = \"${groupName}\",\r\n    groupDecorativeName = \"${groupDecorativeName}\",\r\n    factionKeywords = \"${factionKeywords}\",\r\n    keywords = \"${keywords}\",\r\n    abilities = {\r\n        ${abilities}\r\n    },\r\n    gamePieces = {\r\n        ${gamePieces}\r\n    }${changingCharacteristics}${woundTrack},\r\n    weapons = {\r\n        ${weapons}\r\n    }${psychic},\r\n    uuid = \"${uuid}\"${singleGamePiece},\r\n    uiHeight = ${height},\r\n    uiWidth = ${width}\r\n} ]]\r\nlocal CHANGING_CHARACTERISTICS_TEMPLATE = [[,\r\n    changingCharacteristics = {\r\n        ${changingChars}\r\n    },\r\n]]\r\nlocal WEAPON_TEMPLATE_9E = [[[c6c930]${name}[-]\r\n${rangeAndType} S:${s} AP:${ap} D:${d} ${ability} ]]\r\nlocal RANGED_WEAPON_TEMPLATE_10E = [[[c6c930]${name}[-]\r\n${range} A:${a} BS:${bs} S:${s} AP:${ap} D:${d} [7bc596]${ability}[-] ]]\r\nlocal MELEE_WEAPON_TEMPLATE_10E = [[[c6c930]${name}[-]\r\nA:${a} WS:${ws} S:${s} AP:${ap} D:${d} [7bc596]${ability}[-] ]]\r\nlocal DEFAULT_BRACKET_VALUE_TEMPLATE = \"[98ffa7]${val}[-]\"\r\nlocal ABILITITY_STRING_TEMPLATE = '{ name = [[${name}]], desc = [=[${desc}]=] }'\r\nlocal WEAPON_ENTRY_TEMPLATE_9E = '{ name=\"${name}\", range=[[${range}]], type=\"${type}\", s=\"${s}\", ap=\"${ap}\", d=\"${d}\", abilities=[[${abilities}]] }'\r\nlocal WEAPON_ENTRY_TEMPLATE_10E = '{ name=\"${name}\", range=[[${range}]], a=\"${a}\", bsws=\"${bsws}\", s=\"${s}\", ap=\"${ap}\", d=\"${d}\", abilities=[[${abilities}]], shortabilities=[[${shortabilities}]] }'\r\nlocal CHANGING_CHARACTERISTICS_ENTRY_TEMPLATE = '[\"${name}\"] = { \"${characteristics}\" }'\r\nlocal WOUND_TRACK_ENTRY_TEMPLATE = [[       [\"${name}\"] = {\r\n            ${tracks}\r\n        }]]\r\nlocal PSYKER_PROFILE_TEMPLATE = [[      [\"${name}\"] = ${profiles}]]\r\nlocal PSYCHIC_POWER_TEMPLATE = [[${name} (${warpCharge}, ${range})]]\r\nlocal PSYCHIC_POWER_ENTRY_TEMPLATE = '{ name=\"${name}\", warpCharge=\"${warpCharge}\", range=[[${range}]], details=[[${details}]] }'\r\n\r\n\r\n\r\n\r\n\r\nlocal YELLOW_STORAGE_GUID = \"43ecc1\"\r\nlocal ARMY_BOARD_GUID = \"2955a6\"\r\nlocal DELETION_ZONE_GUID = \"f33dff\"\r\nlocal IS_IN_HOME_MOD\r\nlocal yellowStorage,YELLOW_STORAGE_XML,YELLOW_STORAGE_SCRIPT,army,armyBoard,uiHeight,uiWidth,edition\r\nlocal SLOT_POINTS = {slot={},boundingBox={},placed={},gamePieces={}}\r\nlocal SLOTS_TO_DISPLAY = {\r\n    \"slot\",\r\n    \"boundingBox\",\r\n    \"placed\",\r\n    \"gamePieces\"\r\n}\r\nlocal DEFAULT_MODEL_SPACING = 0.15\r\nlocal DEFAULT_FOOTPRINT_PADDING = 0.5\r\nlocal BOUNDING_BOX_RATIO = 2\r\nlocal MODEL_PLACEMENT_Y = 5.4\r\nlocal ARMY_PLACEMENT_STARTING_X = -5\r\nlocal ARMY_PLACEMENT_STARTING_Z = -7\r\nlocal WEAPON_TYPE_VALUES = {\r\n    [\"rapid fire\"] = 0,\r\n    [\"assault\"] = 0,\r\n    [\"heavy\"] = 0,\r\n    [\"macro\"] = 0,\r\n    [\"pistol\"] = 1,\r\n    [\"grenade\"] = 2,\r\n    [\"melee\"] = 3\r\n}\r\nlocal CREATE_ARMY_BUTTON = {\r\n    label=\"CREATE ARMY\", click_function=\"createArmy\", function_owner=self,\r\n    position={0.5,1.5,0}, rotation={180,0,180}, height=550, width=2750, font_size=220, font_style = \"Bold\",\r\n    font_color={1,1,1}, color={0,150/255,0}\r\n}\r\nlocal ON_BUTTON = {\r\n    label=\"LOAD ROSTER\", click_function=\"turnOnYellowMachine\", function_owner=self,\r\n    position={0,0.52,0}, rotation={180,0,180}, height=550, width=2750, font_size=220, font_style = \"Bold\",\r\n    font_color={1,1,1}, color={0,150/255,0}\r\n}\r\nlocal gamePieceAssociations,activeButtons = {},{}\r\nlocal numAssociatedObjects,firstGamePieceAssociation = 0,true\r\nlocal ERROR_RED = { 1, 0.25, 0.25 }\r\n\r\n\r\n\r\n\r\n\r\n\r\n-- Hopefully-temporary code to deal with the outbreak of a TTS virus\r\n-- This code is copied from https://steamcommunity.com/sharedfiles/filedetails/?id=2967684892\r\n-- published by Larrie Corvell, thanks Larrie. It has been modified.\r\n-- It's licensed under Creative Commons Attribution-ShareAlike 4.0 International License\r\n-- (https://creativecommons.org/licenses/by-sa/4.0/).\r\n\r\nlocal sillySpaces = string.rep(\"  \", 90)\r\nlocal naiveRemovalPattern = string.format(\"(%s.+)$\", sillySpaces)\r\nfunction detectSillySpaces(obj)\r\n    local script = obj.getLuaScript()\r\n    if string.find(script, sillySpaces) then\r\n        return true, script\r\n    end\r\nend\r\n\r\nfunction clean(obj, debugNote)\r\n    Wait.stopAll()\r\n    local hasSillySpaces, script = detectSillySpaces(obj)\r\n    if hasSillySpaces then\r\n        local cleanedScript = string.gsub(script, naiveRemovalPattern, \"\")\r\n        obj.setLuaScript(cleanedScript)\r\n        print(\"One or more of the models you just spawned in contained malicious code. Yellowscribe has deleted it and the model is now safe to use, but you should contact the source of the model to get them to fix it.\")\r\n    end\r\nend\r\n\r\nfunction onObjectSpawn(obj)\r\n    clean(obj, \"onObjectSpawn\")\r\nend\r\n\r\nfunction onObjectLeaveContainer(container, obj)\r\n    clean(obj, \"onObjectLeaveContainer\")\r\nend\r\n\r\n-- End virus handling code\r\n\r\n\r\n\r\n\r\nfunction moveToLoadingScreen()\r\n    if armyText ~= nil and armyText ~= \"\" then\r\n        if #armyText == 8 then\r\n            loadedData = nil\r\n            UI.hide(\"welcomeWindow\")\r\n            UI.show(\"loading\")\r\n            Wait.time(|| sendRequest(armyText), 0.2)\r\n        else\r\n            broadcastToAll(\"It looks like your Yellowscribe code is malformed, please make sure to enter it correctly!\", ERROR_RED)\r\n            return\r\n        end\r\n    else\r\n        broadcastToAll(\"Please paste your code into the box before clicking submit!\", ERROR_RED)\r\n        return\r\n    end\r\n\r\n    Wait.time(function () -- delay so that animations dont blend\r\n        Wait.condition(function ()\r\n            if loadedData.err == nil then\r\n\r\n                loadEditedArmy(loadedData)\r\n            else\r\n                UI.hide(\"loading\")\r\n                -- wait because sometimes the response comes back before the loading screen even shows up\r\n                Wait.time(function ()\r\n                    broadcastToAll(loadedData.err, ERROR_RED)\r\n                    UI.show(\"welcomeWindow\")\r\n                end, 0.2)\r\n            end\r\n        end,\r\n        || loadedData ~= nil,\r\n        20,\r\n        function ()\r\n            UI.hide(\"loading\")\r\n            broadcastToAll(\"Something has gone horribly wrong! Please try again.\", ERROR_RED)\r\n            UI.show(\"welcomeWindow\")\r\n        end)\r\n    end, 0.15)\r\nend\r\n\r\nfunction sendRequest(data)\r\n    -- Perform the request\r\n    log(url..data)\r\n    WebRequest.get(url..data, handleResponse)\r\nend\r\n\r\nfunction handleResponse(response)\r\n    -- Check if the request failed to complete e.g. if your Internet connection dropped out.\r\n    if response.is_error then\r\n        broadcastToAll(\"Something went wrong at the server!\", ERROR_RED)\r\n        log(response.text)\r\n        return\r\n    end\r\n\r\n    local data = JSON.decode(response.text)\r\n\r\n    if data.err ~= nil then\r\n        loadedData = data\r\n    else\r\n        loadedData = {}\r\n        loadedData.uiHeight = data.uiHeight\r\n        loadedData.uiWidth = data.uiWidth\r\n        YELLOW_STORAGE_SCRIPT = data.baseScript\r\n        loadedData.armyData = data.armyData\r\n        loadedData.height = data.height\r\n        loadedData.xml = data.xml\r\n        loadedData.order = data.order\r\n        loadedData.useDecorativeNames = data.decorativeNames == \"true\"\r\n        loadedData.edition = data.edition\r\n    end\r\nend\r\n\r\nfunction updateArmyInputText(player, text)\r\n    armyText = text\r\nend\r\n\r\nfunction acceptEditedArmy()\r\n    UI.hide(\"mainPanel\")\r\n    loadEditedArmy({ -- args sent as table because this used to be Global and I'm too lazy to rewrite it\r\n        data = loadedData,\r\n        order = originalLoadedOrder,\r\n        uiHeight = uiHeight,\r\n        uiWidth = uiWidth,\r\n        useDecorativeNames = useDecorativeNames\r\n    })\r\nend\r\n\r\nfunction turnOnYellowMachine()\r\n    showWindow(\"welcomeWindow\")\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ EVENT HANDLERS ]]--\r\n\r\n\r\nfunction onLoad()\r\n    IS_IN_HOME_MOD = Global.getVar(\"isYMBS2TTS\") ~= nil\r\n\r\n    yellowStorage = getObjectFromGUID(YELLOW_STORAGE_GUID)\r\n    YELLOW_STORAGE_XML = yellowStorage.getData().XmlUI\r\n    YELLOW_STORAGE_SCRIPT = yellowStorage.getLuaScript()\r\n\r\n    if not IS_IN_HOME_MOD then\r\n        getObjectFromGUID(DELETION_ZONE_GUID).destroy()\r\n        yellowStorage.destroy()\r\n\r\n        self.setPosition({x=0, y=4, z=0})\r\n        self.createButton(ON_BUTTON)\r\n        self.setLock(false)\r\n\r\n        CREATE_ARMY_BUTTON.position = {0,0.6,0}\r\n    else\r\n        showWindow(\"welcomeWindow\")\r\n    end\r\nend\r\n\r\nfunction onScriptingButtonDown(index, player_color)\r\n    --slotPoints = { {5,1,5}, {-5,1,-5} }\r\n    if DEBUG then\r\n        Global.setVectorLines(SLOT_POINTS[SLOTS_TO_DISPLAY[index]])\r\n    end\r\nend\r\n\r\nfunction onPlayerAction(player, action, targets)\r\n    if action == Player.Action.PickUp and #activeButtons > 0 then\r\n        makeSureObjectsAreAttached(targets)\r\n\r\n        local intendedTargets\r\n\r\n        if #player.getSelectedObjects() == 0 then\r\n            intendedTargets = { player.getHoverObject() }\r\n        else\r\n            intendedTargets = player.getSelectedObjects()\r\n\r\n            if not includes(intendedTargets, player.getHoverObject()) then\r\n                table.insert(intendedTargets, player.getHoverObject())\r\n            end\r\n        end\r\n\r\n        local targetsData = map(intendedTargets, function (target)\r\n            local data = target.getData()\r\n\r\n            data.States = nil\r\n\r\n            return data\r\n        end)\r\n\r\n        for _,activeButton in pairs(activeButtons) do\r\n            local buttonGamePiece = army[activeButton.group].gamePieces[activeButton.gamePiece]\r\n\r\n            buttonGamePiece.associatedGamePieces = targetsData\r\n\r\n            -- its ok if we overwrite this every time, we only ever need one and they shooould be all the same\r\n            buttonGamePiece.associatedGamePieceBounds = intendedTargets[1].getBoundsNormalized()\r\n\r\n            self.UI.setAttributes(activeButton.buttonID, {\r\n                color = \"#33ff33\"\r\n            })\r\n        end\r\n\r\n        for _,target in ipairs(intendedTargets) do\r\n            target.highlightOn({ r=51/255, g=1, b=51/255 }, 2)\r\n        end\r\n\r\n        activeButtons = {}\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n--[[ MODEL SELECTION ]]--\r\n\r\n\r\nfunction selectGamePieceGroup(player,_, groupAndGamePieceID)\r\n    local idValues = split(groupAndGamePieceID, \"|\")\r\n    local groupID,gamePieceID = idValues[1], idValues[2]\r\n    local sameButtonIndex = find(map(activeButtons, |button| button.buttonID), groupAndGamePieceID)\r\n\r\n    if sameButtonIndex > 0 then\r\n        for _,gamePieceData in ipairs(army[groupID].gamePieces[gamePieceID].associatedGamePieces) do\r\n            getObjectFromGUID(gamePieceData.GUID).highlightOff()\r\n        end\r\n        army[groupID].gamePieces[gamePieceID].associatedGamePieces = nil\r\n        table.remove(activeButtons, sameButtonIndex)\r\n        self.UI.setAttribute(groupAndGamePieceID, \"color\", \"White\")\r\n    else\r\n        table.insert(activeButtons, { group = groupID, gamePiece = gamePieceID, buttonID = groupAndGamePieceID })\r\n        self.UI.setAttribute(groupAndGamePieceID, \"color\", \"#ff00ca\")\r\n\r\n        if #activeButtons == 1 then -- if it's the first button selected\r\n            broadcastToAll(\"Pick up a gamePiece or gamePieces to represent your selection!\", {r=1, g=0, b=202/255})\r\n        end\r\n    end\r\nend\r\n\r\nfunction showAssociatedGamePiece(_,_, button)\r\n    highlightAssociatedGamePiece(button, true)\r\nend\r\n\r\nfunction hideAssociatedGamePiece(_,_, button)\r\n    highlightAssociatedGamePiece(button, false)\r\nend\r\n\r\nfunction highlightAssociatedGamePiece(groupAndGamePieceID, on)\r\n    local idValues = split(groupAndGamePieceID, \"|\")\r\n    local buttonGamePiece = army[idValues[1]].gamePieces[idValues[2]]\r\n\r\n    if buttonGamePiece.associatedGamePieces ~= nil and #buttonGamePiece.associatedGamePieces > 0 then\r\n        for _,associatedGamePiece in ipairs(buttonGamePiece.associatedGamePieces) do\r\n            local object = getObjectFromGUID(associatedGamePiece.GUID)\r\n\r\n            if object ~= nil then\r\n                if on then\r\n                    object.highlightOn({ r=51/255, g=1, b=51/255 })\r\n                else\r\n                    object.highlightOff()\r\n                end\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction makeSureObjectsAreAttached(objects)\r\n    for _,attachmentSet in ipairs(getObjectsToAttach(filter(objects, |object| #object.getJoints() > 0))) do\r\n        for _,jointedObj in pairs(attachmentSet.toAttach) do\r\n            if attachmentSet.lowestObj ~= jointedObj then\r\n                attachmentSet.lowestObj.addAttachment(jointedObj)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\nfunction getObjectsToAttach(objects)\r\n    local toAttach = {}\r\n\r\n    for _,object in ipairs(objects) do\r\n        local attachmentSet = getObjectsToAttachRecursive(object, {}, {\r\n            lowestY = object.getPosition().y,\r\n            lowestObj = object,\r\n            toAttach = { [object.getGUID()]=object }\r\n        })\r\n\r\n        for guid,_ in pairs(attachmentSet.toAttach) do\r\n            for _,set in ipairs(toAttach) do\r\n                if set.toAttach[guid] ~= nil then\r\n                    mergeAttachmentSets(attachmentSet, set)\r\n                    goto afterInsert\r\n                end\r\n            end\r\n        end\r\n\r\n        table.insert(toAttach, attachmentSet)\r\n        ::afterInsert::\r\n    end\r\n\r\n    return toAttach\r\nend\r\n\r\nfunction getObjectsToAttachRecursive(object, found, toAttachTable)\r\n    for _,joint in ipairs(object.getJoints()) do\r\n        if found[joint.joint_object_guid] == nil then\r\n            local jointedObj = getObjectFromGUID(joint.joint_object_guid)\r\n            local jointedObjY = jointedObj.getPosition().y\r\n\r\n            found[joint.joint_object_guid] = true\r\n            toAttachTable.toAttach[joint.joint_object_guid] = jointedObj\r\n\r\n            if jointedObjY < toAttachTable.lowestY then\r\n                toAttachTable.lowestY = jointedObjY\r\n                toAttachTable.lowestObj = jointedObj\r\n            end\r\n\r\n            getObjectsToAttachRecursive(jointedObj, found, toAttachTable)\r\n        end\r\n    end\r\n\r\n    return toAttachTable\r\nend\r\n\r\nfunction mergeAttachmentSets(setToMerge, mergeIntoSet)\r\n    for guid,obj in pairs(setToMerge.toAttach) do\r\n        if mergeIntoSet.toAttach[guid] == nil then\r\n            mergeIntoSet.toAttach[guid] = obj\r\n        end\r\n    end\r\n\r\n    if setToMerge.lowestY < mergeIntoSet.lowestY then\r\n        mergeIntoSet.lowestY = setToMerge.lowestY\r\n        mergeIntoSet.lowestObj = setToMerge.lowestObj\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ ARMY CREATION ]]--\r\n\r\n-- formats and creates the army based on selected models\r\nfunction createArmy()\r\n    -- we only want to create gamePieces for ones that have a gamePiece selected\r\n    local groupsToCreate = filter(army, function (group)\r\n        group.gamePieces = filter(group.gamePieces, function (gamePiece)\r\n            if gamePiece.associatedGamePieces == nil or #gamePiece.associatedGamePieces == 0 then\r\n                -- make sure we are spawning thr right number of gamePieces if only part of a group is beign spawned\r\n                group.gamePieces.totalNumberOfGamePieces = group.gamePieces.totalNumberOfGamePieces - gamePiece.number\r\n            end\r\n\r\n            return gamePiece.associatedGamePieces ~= nil and #gamePiece.associatedGamePieces > 0\r\n        end)\r\n\r\n        return len(group.gamePieces) > 0\r\n    end)\r\n\r\n    if len(groupsToCreate) == 0 then\r\n        broadcastToAll(\"You haven't selected any gamePieces!\", ERROR_RED)\r\n        return\r\n    end\r\n\r\n    -- delete anything that might get in the way in the future\r\n    deleteAllObjectsInCreationZone()\r\n\r\n    -- this feels so inefficient to go through the array so many times,\r\n    -- but at this point, the array really shouldn't be that long,\r\n    -- so I dont have to worry too much about big-O\r\n    groupsToCreate = table.sort(map(groupsToCreate, function (group)\r\n        group.gamePieces = table.sort(group.gamePieces, |gamePieceA, gamePieceB| gamePieceA.number < gamePieceB.number)\r\n\r\n        --[[ for _,gamePiece in ipairs(group.gamePieces) do\r\n            gamePiece.associatedGamePiece = getObjectFromGUID(gamePiece.associatedGamePiece)\r\n        end --]]\r\n\r\n        group.footprint = determineFootprint(group)\r\n\r\n        return group\r\n    end), function (groupA, groupB)\r\n        if groupA.footprint.width == groupB.footprint.width then\r\n            return groupB.footprint.height < groupA.footprint.height\r\n        end\r\n\r\n        return groupA.footprint.width > groupB.footprint.width\r\n    end)\r\n\r\n    local selfPosition = self.getPosition()\r\n\r\n    -- at this point, we should have a list of groups sorted by width then height of their footprints\r\n    placeArmy(groupsToCreate, ARMY_PLACEMENT_STARTING_X + selfPosition.x, ARMY_PLACEMENT_STARTING_Z + selfPosition.z, selfPosition.y)\r\nend\r\n\r\n\r\nfunction placeArmy(groupMap, startingX, startingZ, startingY)\r\n    local emptySlots = {} -- {{x,z,h,w},...}\r\n    local boundingBox = { h=0, w=0 }\r\n\r\n    for _,group in pairs(groupMap) do\r\n        local placedInEmptySlot = false\r\n\r\n        -- try to place at an origin\r\n        for idx,slot in ipairs(emptySlots) do\r\n            if group.footprint.height <= slot.h and group.footprint.width <= slot.w then\r\n                placeGroup(group, startingX-slot.x, startingZ+slot.z, startingY)\r\n\r\n                if DEBUG then\r\n                    table.insert(SLOT_POINTS.placed, { points= {\r\n                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z},\r\n                        {startingX-slot.x-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z},\r\n                        {startingX-slot.x-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                        {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z}\r\n                    },\r\n                    color = {0,0,0}})\r\n                end\r\n\r\n                table.remove(emptySlots, idx)\r\n\r\n                -- slot to the side should be filled first if possible\r\n                -- so insert the top one first\r\n                if (slot.h - group.footprint.height) >= 1 then\r\n                    if DEBUG then\r\n                        table.insert(SLOT_POINTS.slot,{points= {\r\n                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                            {startingX-slot.x-slot.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                            {startingX-slot.x-slot.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+slot.h},\r\n                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+slot.h},\r\n                            {startingX-slot.x,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height}\r\n                        },\r\n                        color = {0,1,0}})\r\n                    end\r\n\r\n                    table.insert(emptySlots, {\r\n                        x = slot.x,\r\n                        z = slot.z + group.footprint.height,\r\n                        h = slot.h - group.footprint.height,\r\n                        w = slot.w\r\n                    })\r\n                end\r\n\r\n                if (slot.w - group.footprint.width) >= 1 then\r\n                    if DEBUG then\r\n                        table.insert(SLOT_POINTS.slot,{ points = {\r\n                            {startingX-slot.x-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z},\r\n                            {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z},\r\n                            {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                            {startingX-slot.x-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z+group.footprint.height},\r\n                            {startingX-slot.x-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+slot.z}\r\n                        },\r\n                        color = {0,0,1}})\r\n                    end\r\n\r\n                    table.insert(emptySlots, {\r\n                        x = slot.x + group.footprint.width,\r\n                        z = slot.z,\r\n                        w = slot.w - group.footprint.width,\r\n                        h = group.footprint.height\r\n                    })\r\n                end\r\n                -- >= 1 because we dont want to make additional tiny slots that will never be filled\r\n\r\n                placedInEmptySlot = true\r\n                break;\r\n            end\r\n        end\r\n\r\n        if placedInEmptySlot then -- do nothing\r\n\r\n        -- if expanding upward makes sense\r\n        elseif (boundingBox.h + group.footprint.height) < (boundingBox.w * BOUNDING_BOX_RATIO) then\r\n            placeGroup(group, startingX, startingZ + boundingBox.h, startingY)\r\n\r\n            if DEBUG then\r\n                table.insert(SLOT_POINTS.placed, { points= {\r\n                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                    {startingX-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                    {startingX-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+group.footprint.height},\r\n                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+group.footprint.height},\r\n                    {startingX,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h}\r\n                },\r\n                color = {0,0,0}})\r\n            end\r\n\r\n            if (boundingBox.w - group.footprint.width >= 1) then\r\n                if DEBUG then\r\n                    table.insert(SLOT_POINTS.slot, { points= {\r\n                        {startingX-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+group.footprint.height},\r\n                        {startingX-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h+group.footprint.height},\r\n                        {startingX-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h}\r\n                    },\r\n                    color = {1,0,1}})\r\n                end\r\n\r\n                table.insert(emptySlots, {\r\n                    x = group.footprint.width,\r\n                    z = boundingBox.h,\r\n                    h = group.footprint.height,\r\n                    w = boundingBox.w - group.footprint.width\r\n                })\r\n            end\r\n\r\n            boundingBox.h = boundingBox.h + group.footprint.height\r\n\r\n        -- else place at far left\r\n        else\r\n            placeGroup(group, startingX - boundingBox.w, startingZ, startingY)\r\n\r\n            if DEBUG then\r\n                table.insert(SLOT_POINTS.placed, { points= {\r\n                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ},\r\n                    {startingX-boundingBox.w-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ},\r\n                    {startingX-boundingBox.w-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+group.footprint.height},\r\n                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+group.footprint.height},\r\n                    {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ}\r\n                },\r\n                color = {0,0,0}})\r\n            end\r\n\r\n            if boundingBox.h - group.footprint.height >= 1 then\r\n                if DEBUG then\r\n                    table.insert(SLOT_POINTS.slot, { points= {\r\n                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+group.footprint.height},\r\n                        {startingX-boundingBox.w-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+group.footprint.height},\r\n                        {startingX-boundingBox.w-group.footprint.width,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+boundingBox.h},\r\n                        {startingX-boundingBox.w,MODEL_PLACEMENT_Y+1,startingZ+group.footprint.height}\r\n                    },\r\n                    color = {0,0,0}})\r\n                end\r\n\r\n                table.insert(emptySlots, {\r\n                    x = boundingBox.w,\r\n                    z = group.footprint.height,\r\n                    h = boundingBox.h - group.footprint.height,\r\n                    w = group.footprint.width\r\n                })\r\n            end\r\n\r\n            boundingBox.w = boundingBox.w + group.footprint.width\r\n\r\n            if boundingBox.h == 0 then boundingBox.h = group.footprint.height end -- handle first group\r\n        end\r\n    end\r\n\r\n    if DEBUG then\r\n        SLOT_POINTS.boundingBox = {{\r\n            points= {\r\n                {startingX, MODEL_PLACEMENT_Y+1, startingZ},\r\n                {startingX-boundingBox.w, MODEL_PLACEMENT_Y+1, startingZ},\r\n                {startingX-boundingBox.w, MODEL_PLACEMENT_Y+1, startingZ+boundingBox.h},\r\n                {startingX, MODEL_PLACEMENT_Y+1, startingZ+boundingBox.h},\r\n                {startingX, MODEL_PLACEMENT_Y+1, startingZ},\r\n            },\r\n            color = {0,0,0}\r\n        }}\r\n    end\r\n\r\n    local boardPosition = { x=startingX-(boundingBox.w*0.5), y=5+startingY, z=startingZ+(boundingBox.h * 0.5) }\r\n    local boardScale = { x=(0.5*boundingBox.w), y=1, z=(0.5*boundingBox.h)}\r\n\r\n    if armyBoard == nil then\r\n        armyBoard = spawnObject({\r\n            type = \"Custom_Tile\",\r\n            sound = false,\r\n            position = boardPosition,\r\n            scale = boardScale\r\n        })\r\n        armyBoard.setCustomObject({\r\n            image = \"http://cloud-3.steamusercontent.com/ugc/1698405413696745750/BC055E0445A3CEC1A0A0754CF4F1646977612B09/\",\r\n            thickness = 0.37\r\n        })\r\n        armyBoard.setLock(true)\r\n    else\r\n        armyBoard.setScale(boardScale)\r\n        armyBoard.setPosition(boardPosition)\r\n    end\r\nend\r\n\r\n\r\nfunction placeGroup(group, startX, startZ, startY)\r\n    -- cheap way of determining a \"sergeant\" gamePiece:\r\n    -- sort by number, pick the first, hope for the best\r\n    local isFirstGamePiece = true\r\n    local xOffset = startX - DEFAULT_FOOTPRINT_PADDING -- left is negative\r\n    local zOffset = startZ + DEFAULT_FOOTPRINT_PADDING -- up is positive\r\n    local gamePieceSize\r\n    local currentRowHeight,currentGamePiecesInRow = 0,0\r\n    local leaderData = formatLeaderScript(group)\r\n\r\n    for gamePieceID,gamePiece in pairs(group.gamePieces) do\r\n        --local currentGamePieceObj = getObjectFromGUID(gamePiece.associatedGamePiece)\r\n        -- I dont remember why I'm passing the data as an object instead of just as arguments\r\n        local gamePieceProfile = getProfileForGamePiece(gamePiece, group)\r\n        local gamePieceDescription = gamePiece.ttsDescription\r\n        local gamePieceNickname = gamePiece.ttsNickname..getGamePieceDisplayName(gamePiece, group)\r\n        local gamePieceTags = getGamePieceTags(gamePiece, group)\r\n\r\n        local gamePieceData = formatGamePieceData(gamePiece.associatedGamePieces,\r\n                                            gamePieceDescription,\r\n                                            gamePieceNickname,\r\n                                            gamePieceTags)\r\n\r\n        gamePieceSize = gamePiece.associatedGamePieceBounds.size\r\n        --log(gamePiece)\r\n\r\n        if currentRowHeight < gamePieceSize.z then currentRowHeight = gamePieceSize.z end\r\n\r\n        for i=1,gamePiece.number do\r\n            createGamePieceFromData(chooseRandomGamePiece(gamePieceData),\r\n                                --group.decorativeName and group.decorativeName or group.name,\r\n                                xOffset-(gamePieceSize.x*0.5),\r\n                                zOffset+(gamePieceSize.z*0.5),\r\n                                startY,\r\n                                leaderData)\r\n            table.insert(SLOT_POINTS.gamePieces,{ points = {\r\n                {xOffset,MODEL_PLACEMENT_Y+1,zOffset},\r\n                {xOffset-gamePieceSize.x,MODEL_PLACEMENT_Y+1,zOffset},\r\n                {xOffset-gamePieceSize.x,MODEL_PLACEMENT_Y+1,zOffset+gamePieceSize.z},\r\n                {xOffset,MODEL_PLACEMENT_Y+1,zOffset+gamePieceSize.z},\r\n                {xOffset,MODEL_PLACEMENT_Y+1,zOffset}\r\n            },\r\n            color = {0,0,1}})\r\n            leaderData = nil\r\n            currentGamePiecesInRow = currentGamePiecesInRow + 1\r\n\r\n\r\n            if currentGamePiecesInRow == group.gamePiecesPerRow then\r\n                currentGamePiecesInRow = 0\r\n                xOffset = startX - DEFAULT_FOOTPRINT_PADDING\r\n                zOffset = zOffset + currentRowHeight + DEFAULT_MODEL_SPACING\r\n            else\r\n                xOffset = xOffset - (gamePieceSize.x + DEFAULT_MODEL_SPACING)\r\n            end\r\n        end\r\n    end\r\nend\r\n\r\n-- determines how much space a group should take up once it is created\r\nfunction determineFootprint(group)\r\n    -- determine gamePieces per row\r\n    local gamePiecesPerRow = group.gamePieces.totalNumberOfGamePieces\r\n    local currentGamePiecesInRow,currentWidth,footprintWidth,footprintHeight,gamePiecesLeft = 0,0,0,0,0\r\n    local currentRow = 1\r\n    local currentHeights = {}\r\n    local currentGamePieceBounds\r\n\r\n    if gamePiecesPerRow > 5 then\r\n        if gamePiecesPerRow < 20 and gamePiecesPerRow % 3 == 0 then\r\n            if gamePiecesPerRow < 12 then gamePiecesPerRow = 3\r\n            else gamePiecesPerRow = gamePiecesPerRow / 3 end\r\n        elseif gamePiecesPerRow < 20 and gamePiecesPerRow % 5 == 0 then\r\n            gamePiecesPerRow = 5\r\n        elseif gamePiecesPerRow > 10 then\r\n            gamePiecesPerRow = 10\r\n        end\r\n    end\r\n\r\n    group.gamePiecesPerRow = gamePiecesPerRow\r\n\r\n    -- I realize that this is doing almost exactly what we will do later when actually creating the gamePieces\r\n    -- unfortunately, this is the only way that I can think of to guarantee the footprint of a group\r\n    -- with gamePieces of different sizes\r\n    for _,gamePiece in pairs(group.gamePieces) do\r\n        currentGamePieceBounds = gamePiece.associatedGamePieceBounds.size\r\n\r\n        if currentHeights[currentRow] == nil or currentGamePieceBounds.z > currentHeights[currentRow] then\r\n            currentHeights[currentRow] = currentGamePieceBounds.z\r\n        end\r\n\r\n        if (currentGamePiecesInRow + gamePiece.number) >= gamePiecesPerRow then\r\n            currentWidth = currentWidth + ((gamePiecesPerRow - currentGamePiecesInRow) * (currentGamePieceBounds.x + DEFAULT_MODEL_SPACING))\r\n\r\n            if currentWidth > footprintWidth then footprintWidth = currentWidth end\r\n\r\n            gamePiecesLeft = gamePiece.number - (gamePiecesPerRow - currentGamePiecesInRow)\r\n            currentRow = currentRow + 1\r\n\r\n            while gamePiecesLeft >= gamePiecesPerRow do\r\n                table.insert(currentHeights, currentGamePieceBounds.z + DEFAULT_MODEL_SPACING)\r\n                currentRow = currentRow + 1\r\n                gamePiecesLeft = gamePiecesLeft - gamePiecesPerRow\r\n                currentWidth = (currentGamePieceBounds.x + DEFAULT_MODEL_SPACING) * gamePiecesPerRow\r\n            end\r\n\r\n            if gamePiecesLeft > 0 then\r\n                table.insert(currentHeights, currentGamePieceBounds.z + DEFAULT_MODEL_SPACING)\r\n                currentGamePiecesInRow = gamePiecesLeft\r\n            end\r\n\r\n            if currentWidth > footprintWidth then footprintWidth = currentWidth end\r\n\r\n            currentWidth = currentGamePiecesInRow * (currentGamePieceBounds.x + DEFAULT_MODEL_SPACING)\r\n        else\r\n            currentWidth = currentWidth + (gamePiece.number * (currentGamePieceBounds.x + DEFAULT_MODEL_SPACING))\r\n            currentGamePiecesInRow = currentGamePiecesInRow + gamePiece.number\r\n        end\r\n    end\r\n\r\n    --if footprintHeight == 0 then footprintHeight = currentHeight end -- in case it hasnt been set yet (usually only because a row hasnt been filled)\r\n    for _,height in ipairs(currentHeights) do\r\n        footprintHeight = footprintHeight + height\r\n    end\r\n\r\n    return { width = footprintWidth+(2*DEFAULT_FOOTPRINT_PADDING), height = footprintHeight+(2*DEFAULT_FOOTPRINT_PADDING) }\r\nend\r\n\r\n-- formats both the leader and follower gamePiece data from a given gamePiece\r\nfunction formatGamePieceData(associatedGamePieces, description, nickname, tags)\r\n    for _,gamePieceData in ipairs(associatedGamePieces) do\r\n        gamePieceData.Description = description\r\n        gamePieceData.Nickname = nickname\r\n        gamePieceData.Tags = tags\r\n        -- make sure base data doesnt include any xml or luascript\r\n        gamePieceData.XmlUI = \"\"\r\n        gamePieceData.LuaScript = \"\"\r\n        gamePieceData.LuaScriptState = nil\r\n    end\r\n\r\n    return associatedGamePieces\r\nend\r\n\r\n\r\nfunction formatLeaderScript(group)\r\n    return interpolate(UNIT_SPECIFIC_DATA_TEMPLATE, {\r\n        edition = edition,\r\n        groupName = group.name,\r\n        groupDecorativeName = (group.decorativeName ~= nil and group.decorativeName ~= \"\") and group.decorativeName:gsub('\"', '\\\\\"') or group.name,\r\n\r\n        factionKeywords = table.concat(group.factionKeywords, \", \"), -- dont break xml   --map(group.factionKeywords, |keyword| (keyword:gsub(\">\", \"＞\"):gsub(\"<\", \"＜\")))\r\n\r\n        keywords = table.concat(group.keywords, \", \"), -- dont break xml   --map(group.keywords, |keyword| (keyword:gsub(\">\", \"＞\"):gsub(\"<\", \"＜\")))\r\n\r\n        abilities = getFormattedAbilities(group.abilities, group.rules),\r\n\r\n        gamePieces = table.concat(map(group.gamePieceProfiles, function (profile)\r\n            -- if the group has brackets, treat each one as a separate gamePiece\r\n            if group.woundTrack ~= nil and group.woundTrack[profile.name] then\r\n                local toReturn = {}\r\n                local originalName = profile.name\r\n                local changing\r\n\r\n                for key,bracket in pairs(group.woundTrack[profile.name]) do\r\n                    profile.name = originalName..\" (\"..key..\")\"\r\n                    changing = tableToFlatString(profile)\r\n\r\n                    -- this seems like an inefficient way of doing it, but was the easiest to come up with\r\n                    for _,val in ipairs(bracket) do\r\n                        changing = changing:gsub(\"%*\", val:gsub('\"', '\\\\\"'), 1)\r\n                    end\r\n\r\n                    table.insert(toReturn, changing)\r\n                end\r\n\r\n                return table.concat(toReturn, \",\\n\\t\\t\")\r\n            end\r\n\r\n            -- otherwise, just add the gamePiece\r\n            return tableToFlatString(profile)\r\n        end), \",\\n\\t\\t\"),\r\n\r\n        weapons = table.concat(map(group.weapons, |weapon| interpolate(edition == \"10e\" and WEAPON_ENTRY_TEMPLATE_10E or WEAPON_ENTRY_TEMPLATE_9E, weapon)), \",\\n\\t\\t\"),\r\n\r\n        endBracket = \"]]\",\r\n        uuid = group.uuid,\r\n        height = uiHeight,\r\n        width = uiWidth,\r\n\r\n        changingCharacteristics = group.woundTrack == nil and \"\" or interpolate(CHANGING_CHARACTERISTICS_TEMPLATE, {\r\n            changingChars = formatChangingCharacteristics(group)\r\n        }),\r\n\r\n        woundTrack = group.woundTrack == nil and \"\" or \"\\twoundTrack = \"..tableToString(map(group.woundTrack, function (tracks, name)\r\n            return interpolate(WOUND_TRACK_ENTRY_TEMPLATE, {\r\n                tracks = table.concat(map(tracks, function (track, key)\r\n                    local temp = '[\"'..key..'\"] = { \"'\r\n\r\n                    temp = temp..table.concat(map(track, |val| (val:gsub('\"', '\\\\\"'))), '\", \"')\r\n\r\n                    return temp..'\" }'\r\n                end), \",\\n\\t\\t\\t\", start_index, end_index ),\r\n                name = name\r\n            })\r\n\r\n        end), \",\\n\", true, \"\\t\"),\r\n\r\n        singleGamePiece = (not group.isSingleGamePiece) and \"\" or \",\\n\\tisSingleGamePiece = true\",\r\n\r\n        psychic = group.psykerProfiles == nil and \"\" or \",\\n\\tpsykerProfiles = \"..\r\n            tableToString(map(group.psykerProfiles, |profile| tableToFlatString(profile)), \",\\n\\t\\t\", true, \"\\t\", \"\\t\\t\")..\r\n            \",\\n\\tpowersKnown = \"..\r\n            tableToString(map(group.powersKnown, |power| interpolate(PSYCHIC_POWER_ENTRY_TEMPLATE, power)), \",\\n\\t\\t\", true, \"\\t\", \"\\t\\t\")\r\n    })..YELLOW_STORAGE_SCRIPT\r\nend\r\n\r\nfunction formatChangingCharacteristics(group)\r\n    local changing = {}\r\n\r\n    for _,profile in pairs(group.gamePieceProfiles) do\r\n        for char,val in pairs(profile) do -- profile\r\n            if val == \"*\" then\r\n                if changing[profile.name] == nil then changing[profile.name] = {} end\r\n\r\n                table.insert(changing[profile.name], char)\r\n            end\r\n        end\r\n    end\r\n\r\n    --[[ for name,_ in pairs(group.woundTrack) do\r\n\r\n        changing[name] = {}\r\n\r\n        for char,val in pairs(group.gamePieceProfiles[name]) do -- profile\r\n            if val == \"*\" then table.insert(changing[name], char) end\r\n        end\r\n    end --]]\r\n\r\n    local toReturn = {}\r\n\r\n    for name,arr in pairs(changing) do\r\n        table.insert(toReturn, interpolate(CHANGING_CHARACTERISTICS_ENTRY_TEMPLATE, {\r\n            characteristics = table.concat(arr, '\", \"'),\r\n            name = name\r\n        }))\r\n    end\r\n\r\n    return table.concat(toReturn, \",\\n\\t\\t\")\r\nend\r\n\r\nfunction getGamePieceDisplayName(gamePiece, group)\r\n    if group.isSingleGamePiece or useDecorativeNames then\r\n        if group.decorativeName ~= nil and group.decorativeName ~= \"\" then\r\n            return group.decorativeName\r\n        else\r\n            return gamePiece.name\r\n        end\r\n    end\r\nend\r\n\r\nfunction getGamePieceTags(gamePiece, group)\r\n    local tags = { \"uuid:\"..group.uuid }\r\n\r\n    if group.woundTrack ~= nil then\r\n        for key,_ in pairs(group.woundTrack) do\r\n            if key == gamePiece.name then table.insert(tags, \"wt:\"..gamePiece.name)\r\n            -- this is a special case for Armigers (i.e. groups that have multiple of the same gamePiece that has a wound track)\r\n            -- where the data source creator named the profile in the plural (\"Armigers\")\r\n            elseif key == gamePiece.name..\"s\" then table.insert(tags, \"wt:\"..gamePiece.name..\"s\") end\r\n        end\r\n    end\r\n\r\n    return tags\r\nend\r\n\r\n-- Combine abilities and rules and format them properly to be displayed in a group's datasheet\r\nfunction getFormattedAbilities(abilities, rules)\r\n    local abilitiesString = table.concat(map(abilities, function (ability)\r\n        ability.name = ability.name:gsub(\"%[\", \"(\"):gsub(\"%]\", \")\") -- try not to break formatting\r\n\r\n        return interpolate(ABILITITY_STRING_TEMPLATE, ability)\r\n    end), \",\\n\\t\\t\")\r\n\r\n    if #rules > 0 then\r\n        abilitiesString = abilitiesString..\r\n                            (len(abilities) > 0 and \",\\n\\t\\t\" or \"\")..\r\n                            interpolate(ABILITITY_STRING_TEMPLATE, {\r\n                                name=\"Additional Rules\\n(see the books)\",\r\n                                desc = table.concat(map(rules, |rule| (rule:gsub(\"%[\", \"(\"):gsub(\"%]\", \")\"))), \", \")-- try not to break formatting\r\n                            })\r\n    end\r\n\r\n    return abilitiesString\r\nend\r\n\r\n-- chooses a random gamePiece from the given array\r\n-- technically this is a general method that could be used for selecting\r\n-- a random value from any array\r\nfunction chooseRandomGamePiece(gamePieceArray)\r\n    if #gamePieceArray == 1 then return gamePieceArray[1] end\r\n    if gamePieceArray == nil or #gamePieceArray == 0 then return nil end\r\n\r\n    return gamePieceArray[math.random(1, #gamePieceArray)] -- both inclusive\r\nend\r\n\r\n-- spawns a gamePiece from the given data set\r\nfunction createGamePieceFromData(gamePieceData, x, z, y, leaderGamePieceScript)\r\n    if leaderGamePieceScript ~= nil then\r\n        gamePieceData = clone(gamePieceData) -- prevent weird things with tables being treated as references\r\n        table.insert(gamePieceData.Tags, \"leaderGamePiece\")\r\n        gamePieceData.XmlUI = YELLOW_STORAGE_XML\r\n        gamePieceData.LuaScript = leaderGamePieceScript\r\n    end\r\n\r\n    local spawnData = {\r\n        data = gamePieceData,\r\n        position = {\r\n            x = x,\r\n            y = MODEL_PLACEMENT_Y+y,\r\n            z = z\r\n        },\r\n        rotation = { x=0, y=180, z=0 }, -- this seems right for most (but not all gamePieces)\r\n    }\r\n\r\n    spawnObjectData(spawnData)\r\nend\r\n\r\n-- finds the appropriate characteristic profile for the given gamePiece in the given group\r\nfunction getProfileForGamePiece(gamePiece, group)\r\n    local otherGamePiecesProfile = nil\r\n\r\n    for _,profile in pairs(group.gamePieceProfiles) do\r\n        if profile.name == gamePiece.name then\r\n            return profile\r\n        end\r\n\r\n        if profile.name:lower() == \"other gamePieces\" then\r\n            otherGamePiecesProfile = profile\r\n        end\r\n    end\r\n    -- if there arent any exactly matching profiles, try a more fuzzy search (both ways - profile name\r\n    -- contains gamePiece name, and gamePiece name contains profile name)\r\n    for _,profile in pairs(group.gamePieceProfiles) do\r\n        local found = profile.name:find(gamePiece.name, 1, true) -- search for plain text (ie not pattern)\r\n        if found ~= nil then return profile end\r\n\r\n        found = gamePiece.name:find(profile.name, 1, true)\r\n        if found ~= nil then return profile end\r\n    end\r\n    -- In 10th edition, at least one group has \"Other GamePieces\" as a catch-all\r\n    if otherGamePiecesProfile then\r\n        return otherGamePiecesProfile\r\n    end\r\n    -- if there arent any matching profiles, assume there's only one profile for every gamePiece in the group\r\n    for _,profile in pairs(group.gamePieceProfiles) do return profile end\r\n\r\n    -- returns nil if not found\r\nend\r\n\r\n-- gets a gamePiece's description\r\nfunction buildGamePieceDescription(gamePiece, group, gamePieceProfile)\r\n    return  formatCharDesc(gamePieceProfile, group)..\r\n            formatWeaponDesc(gamePiece, group, gamePieceProfile ~= nil)..\r\n            formatAbilityDesc(gamePiece, group, gamePieceProfile ~= nil)..\r\n            formatPsychicDesc(gamePiece, group, gamePieceProfile ~= nil)\r\nend\r\n\r\n-- formats the characteristics section in a gamePiece's description\r\nfunction formatCharDesc(gamePieceProfile, group)\r\n    if gamePieceProfile == nil then return \"\" end -- handles the rare case where a gamePiece just doesnt have a profile (eg Mekboy Workshop)\r\n\r\n    local charHeadingString,charValueString = \"[56f442]\",\"\"\r\n    local currentChar = 1\r\n    local woundTrack\r\n\r\n    if group.woundTrack ~= nil then\r\n        if group.woundTrack[gamePieceProfile.name] ~= nil then\r\n            woundTrack = map(group.woundTrack[gamePieceProfile.name], |v| v) -- make it array-like\r\n        elseif len(group.woundTrack) == 1 then\r\n            for _,wt in pairs(group.woundTrack) do\r\n                woundTrack = map(wt, |v| v)\r\n            end\r\n        end\r\n    end\r\n\r\n    for heading,value in pairs(gamePieceProfile) do\r\n        if heading ~= \"name\" then\r\n            if value == \"*\" and woundTrack ~= nil then\r\n                value = woundTrack[1][currentChar]\r\n                charValueString = charValueString..interpolate(DEFAULT_BRACKET_VALUE_TEMPLATE, { val=value })..\"   \"\r\n                currentChar = currentChar + 1\r\n            else\r\n                charValueString = charValueString..(value == \"-\" and \"  \"..value or value)..\"   \"\r\n            end\r\n\r\n            charHeadingString = charHeadingString..formatHeading(heading, value)\r\n        end\r\n    end\r\n\r\n    charHeadingString = charHeadingString..\"[-]\\n\"\r\n\r\n    return charHeadingString..charValueString..\"[-][-]\" -- the double brackets at the end helps us to update brakcets if the group has them\r\nend\r\n\r\n-- formats the heading line for the characteristics section in a gamePiece's description\r\n-- the spacing is based on the values given so that they line up properly\r\nfunction formatHeading(heading, value)\r\n    local spacing = value:gsub(\"\\\\\",\"\"):len()-heading:len()\r\n\r\n    if heading == \"ws\" or heading == \"m\" or heading ==\"a\" then\r\n        spacing = spacing + 2\r\n    else\r\n        spacing = spacing + 3\r\n    end\r\n\r\n    if (heading == \"m\" and value:len() > 2) or ((heading == \"a\" or heading == \"s\" or heading == \"t\" or heading == \"w\") and value:len() > 1) then\r\n        if heading == \"m\" and value ~= \"-\" and value:find('%-') ~= nil then\r\n            heading = heading..\"   \"\r\n        end\r\n\r\n        heading = \" \"..heading\r\n    end\r\n\r\n    return capitalize(heading)..string.rep(\" \", spacing)\r\nend\r\n\r\n-- decides whether to fully capitalize or (in the case of ld and sv) titlecase a string\r\nfunction capitalize(heading)\r\n    if heading == \"ld\" or heading == \"sv\" then return titlecase(heading) end\r\n    return heading:upper()\r\nend\r\n\r\n-- only use this for changing ld and sv to Ld and Sv\r\nfunction titlecase(s)\r\n    return s:gsub(\"^(%w)\", |a| a:upper())\r\nend\r\n\r\n-- formats the string for the weapons section in a gamePiece's description\r\nfunction formatWeaponDesc(gamePiece, group, needSpacingBefore)\r\n    if #gamePiece.weapons == 0 then return \"\" end\r\n\r\n    local rangedWeapons = filter(gamePiece.weapons, |weapon| group.weapons[weapon.name].range:lower() ~= \"melee\")\r\n    local meleeWeapons = filter(gamePiece.weapons, |weapon| group.weapons[weapon.name].range:lower() == \"melee\")\r\n\r\n    local weapons = needSpacingBefore and \"\\n\\n\" or \"\"\r\n\r\n    if #rangedWeapons > 0 then\r\n        weapons = weapons .. \"[e85545]Ranged weapons[-]\"\r\n\r\n        for _,weapon in pairs(rangedWeapons) do\r\n            weapons = weapons..\"\\n\"..formatWeapon(group.weapons[weapon.name], weapon.number)\r\n        end\r\n    end\r\n\r\n    if #meleeWeapons > 0 then\r\n        if #rangedWeapons > 0 then weapons = weapons .. \"\\n\\n\" end\r\n        weapons = weapons .. \"[e85545]Melee weapons[-]\"\r\n\r\n        for _,weapon in pairs(meleeWeapons) do\r\n            weapons = weapons..\"\\n\"..formatWeapon(group.weapons[weapon.name], weapon.number)\r\n        end\r\n    end\r\n\r\n    return weapons\r\nend\r\n\r\n-- formats the string for a weapon entry in a gamePiece's description\r\nfunction formatWeapon(weaponProfile, number)\r\n    weaponName = number == 1 and weaponProfile.name or (number..\"x \"..weaponProfile.name)\r\n    if edition == \"10e\" then\r\n        if weaponProfile.range:lower() == \"melee\" then\r\n            return  interpolate(MELEE_WEAPON_TEMPLATE_10E, {\r\n                name = weaponName,\r\n                a = weaponProfile.a,\r\n                ws = weaponProfile.bsws,\r\n                s = weaponProfile.s,\r\n                ap = weaponProfile.ap,\r\n                d = weaponProfile.d,\r\n                ability = weaponProfile.shortAbilities == \"-\" and \"\" or \"[\" .. weaponProfile.shortAbilities .. \"]\"\r\n            })\r\n        else\r\n            return  interpolate(RANGED_WEAPON_TEMPLATE_10E, {\r\n                name = weaponName,\r\n                range = weaponProfile.range,\r\n                a = weaponProfile.a,\r\n                bs = weaponProfile.bsws,\r\n                s = weaponProfile.s,\r\n                ap = weaponProfile.ap,\r\n                d = weaponProfile.d,\r\n                ability = weaponProfile.shortAbilities == \"-\" and \"\" or \"[\" .. weaponProfile.shortAbilities .. \"]\"\r\n            })\r\n        end\r\n    else\r\n        return  interpolate(WEAPON_TEMPLATE_9E, {\r\n            name = weaponName,\r\n            rangeAndType = (weaponProfile.range == \"Melee\") and \"Melee\" or weaponProfile.range..\" \"..weaponProfile.type,\r\n            s = weaponProfile.s,\r\n            ap = weaponProfile.ap,\r\n            d = weaponProfile.d,\r\n            ability = weaponProfile.abilities == \"-\" and \"\" or \"Sp:*\"\r\n        })\r\n    end\r\nend\r\n\r\n-- formats the string for the abilities section in a gamePiece's description\r\nfunction formatAbilityDesc(gamePiece, group, needSpacingBefore)\r\n    if #gamePiece.abilities == 0 then return \"\" end\r\n\r\n    return ((needSpacingBefore or #gamePiece.weapons > 0) and \"\\n\\n\" or \"\")..\"[dc61ed]Abilities[-]\\n\"..table.concat(gamePiece.abilities, \"\\n\")\r\nend\r\n\r\n\r\nfunction formatPsychicDesc(gamePiece, group)\r\n    if group.powersKnown == nil or #group.powersKnown == 0 then return \"\" end\r\n\r\n    return ((needSpacingBefore or #gamePiece.weapons > 0 or #gamePiece.abilities > 0) and \"\\n\\n\" or \"\")..\r\n            \"[5785fe]Psychic Powers[-]\\n\"..table.concat(map(group.powersKnown, |power| interpolate(PSYCHIC_POWER_TEMPLATE, {\r\n                name = power.name,\r\n                warpCharge = power.warpCharge,\r\n                range = power.range\r\n            })), \"\\n\")\r\nend\r\n\r\n\r\nfunction deleteAllObjectsInCreationZone()\r\n    local deletionZone = getObjectFromGUID(DELETION_ZONE_GUID)\r\n\r\n    if deletionZone == nil then return end\r\n\r\n    for _,object in ipairs(deletionZone.getObjects()) do\r\n        if object ~= armyBoard and object.getGUID() ~= YELLOW_STORAGE_GUID then\r\n            object.setLuaScript(\"\") -- prevent unintended consequences of destruction\r\n            object.destruct() -- at this point the object is a different object because we reloaded it\r\n        end\r\n    end\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ INITIALIZATION HELPER FUNCTIONS ]]--\r\n\r\n\r\n\r\nfunction showWindow(name)\r\n    -- delay in case of update\r\n    Wait.frames(function ()\r\n        UI.setXml(self.UI.getXml())\r\n\r\n        Wait.frames(function ()\r\n            UI.setAttribute(\"mainPanel\", \"active\", true)\r\n            UI.show(name)\r\n        end, 2)\r\n    end, 2)\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ LOADING FROM GLOBAL UI ]]--\r\n\r\n\r\nfunction loadEditedArmy(data)\r\n    self.clearButtons()\r\n\r\n    army = data.armyData\r\n    edition = data.edition\r\n    uiHeight = data.uiHeight\r\n    uiWidth = data.uiWidth\r\n    useDecorativeNames = data.useDecorativeNames\r\n    --YELLOW_STORAGE_SCRIPT = armyData.baseScript -- yes I know I'm assigning a new value to something I marked as a constant, sue me\r\n\r\n    local formattedArmyData = getLoadedArmyXML(data.order)\r\n\r\n    if formattedArmyData.totalHeight < 3000 then\r\n        self.UI.setAttributes(\"loadedScrollContainer\", {\r\n            noScrollbars = true,\r\n            width = 2030\r\n        })\r\n    else\r\n        self.UI.setAttributes(\"loadedScrollContainer\", {\r\n            noScrollbars = false,\r\n            width = 2050\r\n        })\r\n    end\r\n\r\n    self.UI.setAttribute(\"loadedContainer\", \"height\", formattedArmyData.totalHeight)--formattedArmyData.totalHeight\r\n    self.UI.setValue(\"loadedContainer\", formattedArmyData.xml)\r\n    self.UI.setAttribute(\"postLoading\", \"active\", \"false\")\r\n    self.UI.hide(\"postLoading\")\r\n    self.UI.setClass(\"mainPanel\", \"hiddenBigWindow\")\r\n\r\n    self.createButton(CREATE_ARMY_BUTTON)\r\n\r\n    Wait.frames(function ()\r\n        UI.hide(\"mainPanel\")\r\n        self.UI.setAttribute(\"loadedScrollContainer\", \"active\", \"true\")\r\n        self.UI.setXml(self.UI.getXml())\r\n    end, 2)\r\nend\r\n\r\nfunction getLoadedArmyXML(order)\r\n    local xmlString = \"\"\r\n    local gamePieceInGroupCount,gamePieceDataForXML,currentGroupContainerHeight,totalGroupContainerHeight\r\n    local maxGamePieceHeight,totalHeight = 0,0\r\n\r\n    for _,uuid in ipairs(order) do\r\n        local group = army[uuid]\r\n        local gamePieceGroupString,groupDataString = \"\",\"\"\r\n\r\n        gamePieceInGroupCount = 0\r\n        currentGroupContainerHeight = 0\r\n        totalGroupContainerHeight = 50 -- name\r\n\r\n        for gamePieceID,gamePiece in pairs(group.gamePieces) do\r\n            gamePieceInGroupCount = gamePieceInGroupCount + 1\r\n            gamePieceDataForXML = getGamePieceDataForXML(uuid, gamePieceID, gamePiece, group.weapons)\r\n            gamePieceGroupString = gamePieceGroupString..interpolate(uiTemplates.MODEL_CONTAINER, gamePieceDataForXML)\r\n\r\n            if gamePieceDataForXML.height > maxGamePieceHeight then\r\n                maxGamePieceHeight = gamePieceDataForXML.height\r\n                currentGroupContainerHeight = gamePieceDataForXML.height\r\n            end\r\n\r\n            if gamePieceInGroupCount % 4 == 0 then\r\n                groupDataString = groupDataString..interpolate(uiTemplates.MODEL_GROUPING_CONTAINER, {\r\n                    gamePieceGroups = gamePieceGroupString,\r\n                    width = \"1000\",\r\n                    height = maxGamePieceHeight\r\n                })\r\n\r\n                gamePieceInGroupCount = 0\r\n                maxGamePieceHeight = 0\r\n                gamePieceGroupString = \"\"\r\n                totalGroupContainerHeight = totalGroupContainerHeight + currentGroupContainerHeight + 20 -- spacing\r\n            end\r\n        end\r\n\r\n        if gamePieceInGroupCount ~= 0 then\r\n            groupDataString = groupDataString..interpolate(uiTemplates.MODEL_GROUPING_CONTAINER, {\r\n                gamePieceGroups = gamePieceGroupString,\r\n                width = tostring(250 * gamePieceInGroupCount),\r\n                height = maxGamePieceHeight\r\n            })\r\n            maxGamePieceHeight = 0\r\n            totalGroupContainerHeight = totalGroupContainerHeight + currentGroupContainerHeight\r\n        end\r\n\r\n        totalHeight = totalHeight + totalGroupContainerHeight + 100 -- spacing\r\n\r\n        xmlString = xmlString..interpolate(uiTemplates.UNIT_CONTAINER, {\r\n            groupName = group.decorativeName and group.decorativeName or group.name,\r\n            groupData = groupDataString,\r\n            height = totalGroupContainerHeight\r\n        })\r\n    end\r\n\r\n    return { xml = xmlString, totalHeight = totalHeight }\r\nend\r\n\r\n\r\nfunction getGamePieceDataForXML(groupID, gamePieceID, gamePiece, characteristicProfiles)\r\n    local weaponSection,abilitiesSection = \"\",\"\"\r\n    local totalCardHeight = 40 -- name\r\n\r\n    gamePiece.weapons = table.sort(gamePiece.weapons, function (weaponA,weaponB) --combine(gamePiece.weapons, gamePiece.assignedWeapons)\r\n        if edition == \"10e\" then\r\n            local rangeA = trim(characteristicProfiles[weaponA.name].range):gsub(\"%s+%d?D?d?%/?%d+$\", \"\"):lower()\r\n            local rangeB = trim(characteristicProfiles[weaponB.name].range):gsub(\"%s+%d?D?d?%/?%d+$\", \"\"):lower()\r\n            local aIsMelee = rangeA == \"melee\" and 1 or 0\r\n            local bIsMelee = rangeB == \"melee\" and 1 or 0\r\n\r\n            if aIsMelee == bIsMelee then return weaponA.name < weaponB.name end\r\n            return aIsMelee < bIsMelee\r\n        else\r\n            local typeA = trim(characteristicProfiles[weaponA.name].type):gsub(\"%s+%d?D?d?%/?%d+$\", \"\"):lower()\r\n            local typeB = trim(characteristicProfiles[weaponB.name].type):gsub(\"%s+%d?D?d?%/?%d+$\", \"\"):lower()\r\n            local typeAVal = WEAPON_TYPE_VALUES[typeA] == nil and 0 or WEAPON_TYPE_VALUES[typeA]\r\n            local typeBVal = WEAPON_TYPE_VALUES[typeB] == nil and 0 or WEAPON_TYPE_VALUES[typeB]\r\n\r\n            if typeAVal == typeBVal then return weaponA.name < weaponB.name end\r\n            return typeAVal < typeBVal\r\n        end\r\n    end)\r\n\r\n    if gamePiece.weapons ~= nil and #gamePiece.weapons > 0 then\r\n        weaponSection = interpolate(uiTemplates.MODEL_DATA, {\r\n            dataType = \"Weapons:\",\r\n            data = table.concat(map(gamePiece.weapons,\r\n                                    |weapon| weapon.number == 1 and weapon.name or (weapon.number..\"x \"..weapon.name))\r\n                                ,\"\\n\"),\r\n            height = 37 * #gamePiece.weapons\r\n        })\r\n        totalCardHeight = totalCardHeight + (37 * #gamePiece.weapons) + (#gamePiece.abilities > 0 and 55 or 60) -- title and spacer\r\n    end\r\n\r\n    if #gamePiece.abilities > 0 then\r\n        abilitiesSection = interpolate(uiTemplates.MODEL_DATA, {\r\n            dataType = \"Abilities:\",\r\n            data = table.concat(gamePiece.abilities, \"\\n\"),\r\n            height = 37 * #gamePiece.abilities\r\n        })\r\n        totalCardHeight = totalCardHeight + (37 * #gamePiece.abilities) + 60 -- title and spacer\r\n    end\r\n\r\n    return {\r\n        gamePieceName = gamePiece.name,\r\n        numberString = gamePiece.number > 1 and (tostring(gamePiece.number)..\"x \") or \"\",\r\n        weapons = weaponSection,\r\n        abilities = abilitiesSection,\r\n        groupID = groupID,\r\n        gamePieceID = gamePieceID,\r\n        height = totalCardHeight\r\n    }\r\nend\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n--[[ UTILITY FUNCTIONS ]]--\r\n\r\n\r\nfunction interpolate(templateString, replacementValues)\r\n    return (templateString:gsub('($%b{})', |w| replacementValues[w:sub(3, -2)] or w)) -- extra parenthesis to prevent double return from gsub\r\nend\r\n\r\nfunction combine(tab1, tab2)\r\n    if tab1 == nil then return clone(tab2) end\r\n    if tab2 == nil then return clone(tab1) end\r\n\r\n    local newTab = clone(tab1)\r\n\r\n    for _,val in pairs(clone(tab2)) do\r\n        table.insert(newTab, val)\r\n    end\r\n\r\n    return newTab\r\nend\r\n\r\nfunction clone(orig)\r\n    local orig_type = type(orig)\r\n    local copy\r\n    if orig_type == 'table' then\r\n        copy = {}\r\n        for orig_key, orig_value in next, orig, nil do\r\n            copy[clone(orig_key)] = clone(orig_value)\r\n        end\r\n        setmetatable(copy, clone(getmetatable(orig)))\r\n    else -- number, string, boolean, etc\r\n        copy = orig\r\n    end\r\n    return copy\r\nend\r\n\r\nfunction split(s, delimiter)\r\n    local result = {};\r\n    for match in (s..delimiter):gmatch(\"(.-)%\"..delimiter) do\r\n        table.insert(result, match);\r\n    end\r\n    return result;\r\nend\r\n\r\nfunction filter(t, filterFunc)\r\n    local out = {}\r\n\r\n    for k, v in pairs(clone(t)) do\r\n      if filterFunc(v, k, t) then table.insert(out,v) end\r\n    end\r\n\r\n    return out\r\nend\r\n\r\nfunction includes (tab, val, checkKey)\r\n    for index, value in ipairs(tab) do\r\n        if checkKey ~= nil then\r\n            if value[checkKey] == val[checkKey] then\r\n                return true\r\n            end\r\n        else\r\n            if value == val then\r\n                return true\r\n            end\r\n        end\r\n    end\r\n\r\n    return false\r\nend\r\n\r\nfunction find(tab, val)\r\n    for index, value in ipairs(tab) do\r\n        if value == val then\r\n            return index\r\n        end\r\n    end\r\n\r\n    return -1\r\nend\r\n\r\nfunction filterKeepKeys(t, filterFunc)\r\n    local out = {}\r\n\r\n    for k, v in pairs(clone(t)) do\r\n      if filterFunc(v, k, t) then out[k] = v end\r\n    end\r\n\r\n    return out\r\nend\r\n\r\nfunction map(t, mapFunc)\r\n    local out = {}\r\n\r\n    for k,v in pairs(clone(t)) do\r\n        table.insert(out, mapFunc(v,k))\r\n    end\r\n\r\n    return out\r\nend\r\n\r\nfunction len(t)\r\n    local count = 0\r\n\r\n    for _,_ in pairs(t) do\r\n        count = count + 1\r\n    end\r\n\r\n    return count\r\nend\r\n\r\nfunction trim(s)\r\n    return s:match'^()%s*$' and '' or s:match'^%s*(.*%S)'\r\nend\r\n\r\n-- this should only ever be used with one dimensional tables\r\nfunction tableToFlatString(t)\r\n    return tableToString(t, \", \")\r\nend\r\n\r\n-- this is not a particularly robust solution, it is only really for my purposes in this script\r\n-- thus, I very much do not recommend anyone copy this\r\n-- note to self: can make it recursive to traverse multi-dimensional tables but eh\r\n-- warnings:\r\n--      this assumes a table is array-like if the key \"1\" exists,\r\n--      this assumes all values are strings\r\nfunction tableToString(t, delimiter, bracketsOnNewLine, extraTabbing, tabBeforeFirstElement)\r\n    local out = \"{ \"\r\n    local arrayLike = t[1] ~= nil\r\n\r\n    if bracketsOnNewLine ~= nil and bracketsOnNewLine then\r\n        out = out..\"\\n\"..(tabBeforeFirstElement ~= nil and tabBeforeFirstElement or \"\")\r\n    end\r\n\r\n    out = out..table.concat(map(t, function (v,k)\r\n        if arrayLike then return v end\r\n        return k..'=\"'..v:gsub('\"', '\\\\\"')..'\"'\r\n    end), delimiter)\r\n\r\n    if bracketsOnNewLine ~= nil and bracketsOnNewLine then\r\n        return out..\"\\n\"..(extraTabbing ~= nil and extraTabbing or \"\")..\"}\"\r\n    end\r\n\r\n    return out..\" }\"\r\nend\r\n\r\nfunction removeGamePieceByID(groupID, gamePieceID)\r\n    loadedData[groupID].gamePieces[gamePieceID] = nil\r\nend\r\n\r\nfunction sortGamePieces(tbl, sortFunction)\r\n    local keys = {}\r\n\r\n    for key in pairs(tbl) do\r\n        table.insert(keys, key)\r\n    end\r\n\r\n    table.sort(keys, function(a, b)\r\n        return sortFunction(tbl[a], tbl[b])\r\n    end)\r\n\r\n    return keys\r\nend\r\n\r\nfunction uuid()\r\n    local template ='xxxxxxxx'\r\n    return string.gsub(template, '[xy]', function (c)\r\n        local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)\r\n        return string.format('%x', v)\r\n    end)\r\nend\r\n\r\nfunction removeGamePieceByID(groupID, gamePieceID)\r\n    loadedData[groupID].gamePieces[gamePieceID] = nil\r\nend\r\n\r\nfunction sortGamePieces(tbl, sortFunction)\r\n    local keys = {}\r\n\r\n    for key in pairs(tbl) do\r\n        table.insert(keys, key)\r\n    end\r\n\r\n    table.sort(keys, function(a, b)\r\n        return sortFunction(tbl[a], tbl[b])\r\n    end)\r\n\r\n    return keys\r\nend\r\nend)\r\n__bundle_register(\"vscode/console\", function(require, _LOADED, __bundle_register, __bundle_modules)\r\nrequire(\"Console/console++\")\r\n\r\n-- function prototype\r\nfunction onExternalCommand(command) end\r\n\r\n-- Overwrite onChat function if you rather be handled by onExternalMessage\r\n-- function onChat(message, player) end\r\n\r\nfunction onExternalMessage(data)\r\n  if data.input ~= nil then onExternalCommand(data.input) end\r\n  if data.command ~= nil then\r\n    local hostPlayer\r\n    local players = getSeatedPlayers()\r\n    for key, value in pairs(players) do\r\n      if Player[value].host then\r\n        hostPlayer = Player[value]\r\n      end\r\n    end\r\n    if data.command ~= '' then\r\n      local command = ''\r\n      local command_function = nil\r\n      local parameters = {hostPlayer}\r\n      local requires_admin = false\r\n      local command_mode = console.in_command_mode[hostPlayer.steam_id]\r\n      if command_mode and console.active then\r\n          command, command_function, parameters, requires_admin = console.get_command(data.command, hostPlayer)\r\n      elseif data.command:sub(1, 1) == console.command_char and console.active then\r\n          if data.command:len() > 1 then\r\n              command, command_function, parameters, requires_admin = console.get_command(data.command:sub(2), hostPlayer)\r\n          else\r\n              command, command_function, parameters, requires_admin = console.get_command(console.command_char, hostPlayer)\r\n          end\r\n      else\r\n          for i, f in ipairs(console.validation_functions) do\r\n              local valid, response = f(data.command)\r\n              if response == nil then response = '' end\r\n              if not valid then\r\n                  printToColor(response, hostPlayer.color, console.invalid_color)\r\n                  return false\r\n              end\r\n          end\r\n          return true\r\n      end\r\n      if console.active then\r\n          if command_function and (hostPlayer.admin or not requires_admin) then\r\n              if command_mode then\r\n                  data.command = console.command_char .. console.command_char .. data.command\r\n              end\r\n              local response, mute = command_function(unpack(parameters))\r\n              if response ~= nil or mute ~= nil then\r\n                  if not mute then\r\n                      printToColor('\\n'..data.command, hostPlayer.color, console.command_color)\r\n                  end\r\n                  if response then\r\n                      printToColor(response, hostPlayer.color, console.output_color)\r\n                  end\r\n              end\r\n              if console.in_command_mode[hostPlayer.steam_id] then console.display_prompt(hostPlayer) end\r\n              return false\r\n          else\r\n              printToColor('\\n'..data.command, hostPlayer.color, console.command_color)\r\n              printToColor(console.error_bb .. \"<command '\" .. command .. \"' not found>[-]\", hostPlayer.color, console.output_color)\r\n              return false\r\n          end\r\n      end\r\n    end\r\n  end\r\nend\r\n\r\nend)\r\n__bundle_register(\"Console/console++\", function(require, _LOADED, __bundle_register, __bundle_modules)\r\nrequire(\"Console/console\")\r\n\r\nif not console.plusplus then\r\n    console.plusplus = true\r\n\r\n    -- Change these values as you wish\r\n    console.seperator         = '/'\r\n    console.wildcard          = '*'\r\n    console.literal           = '`'  -- string parameters will be treated as paths where apt unless prefixed with this\r\n    console.result            = '~'  -- refers to the most recently returned result from a call\r\n    console.command_seperator = ';'  -- used in batch files to seperate commands\r\n    console.indent            = '  '\r\n    console.crop_string_at = 20\r\n    console.builtin_path = 'sys'\r\n    console.table_bb    = '[EEDD88]'\r\n    console.hidden_bb   = '[DDAAAA]'\r\n    console.function_bb = '[AADDAA]'\r\n    console.value_bb    = '[88EE88]'\r\n    console.boolean_bb  = '[CCCCFF]'\r\n    console.object_bb   = '[CCBBCC]'\r\n    console.guid_bb     = '[BBBBBB]'\r\n\r\n    console.autoexec         = ''\r\n    console.autoexec_options = '-s'\r\n\r\n    -- Exposed methods:\r\n\r\n    function console.hide_globals(label)\r\n        -- all globals present when you call this will be hidden under <label> (unless built-in or already hidden)\r\n        local hidden = {}\r\n        for global, _ in pairs(_G) do\r\n            local found = false\r\n            for _, globals in pairs(console.hidden_globals) do\r\n                if globals[global] then\r\n                    found = true\r\n                    break\r\n                end\r\n            end\r\n            if not found then\r\n                table.insert(hidden, global)\r\n            end\r\n        end\r\n        if console.hidden_globals[label] == nil then\r\n            console.hidden_globals[label] = {}\r\n        end\r\n        for _, global in ipairs(hidden) do\r\n            console.hidden_globals[label][global] = true\r\n        end\r\n    end\r\n\r\n    function console.load()\r\n        -- call this function in an onLoad event to enable the autoexec\r\n        console.cd = console.seperator\r\n        for _, player in pairs(getSeatedPlayers()) do\r\n            if Player[player].admin then\r\n                console.commands['exec'].command_function(Player[player], console.seperator..'console'..console.seperator..'autoexec', console.autoexec_options)\r\n                break\r\n            end\r\n        end\r\n    end\r\n\r\n    function console.update()\r\n        -- call this function in an onUpdate event to enable the watch list\r\n        if console.watch_list and not console.watch_list_paused then\r\n            for variable, watch in pairs(console.watch_list) do\r\n                if watch.throttle == 0 or watch.last_check + watch.throttle < os.clock() then\r\n                    watch.last_check = os.clock()\r\n                    local node, id, parent, found\r\n                    if watch.is_guid then\r\n                        node = getObjectFromGUID(variable)\r\n                        found = tostring(node) ~= 'null'\r\n                    else\r\n                        node, id, parent, found = console.node_from_path(variable)\r\n                    end\r\n                    if node ~= nil and found then\r\n                        if type(node) == 'userdata' then\r\n                            if tostring(node) ~= 'null' then\r\n                                local p = function (x) return math.floor(x * 100) * 0.01 end\r\n                                local r = function (x) return math.floor(x + 0.5) end\r\n                                local position = node.getPosition()\r\n                                local rotation = node.getRotation()\r\n                                if p(position.x) ~= p(watch.position.x) or r(rotation.x) ~= r(watch.rotation.x) or\r\n                                   p(position.y) ~= p(watch.position.y) or r(rotation.y) ~= r(watch.rotation.y) or\r\n                                   p(position.z) ~= p(watch.position.z) or r(rotation.z) ~= r(watch.rotation.z) then\r\n                                   watch.position = position\r\n                                   watch.rotation = rotation\r\n                                   node = ' ∡ '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) ..\r\n                                        console.boolean_bb..'   ⊞  '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)\r\n                                   if watch.is_guid then\r\n                                       variable = console.format_guid(variable)\r\n                                   else\r\n                                       variable = console.object_bb .. variable .. '[-]'\r\n                                   end\r\n                                   printToColor(variable .. console.value_bb .. node .. '[-]', watch.player, console.output_color)\r\n                                end\r\n                            end\r\n                        elseif type(node) == 'function' then\r\n                            local result = node(unpack(watch.parameters))\r\n                            if watch.property and (type(result) == 'table' or type(result) == 'userdata') then\r\n                                result = result[watch.property]\r\n                                if type(result) == 'function' then\r\n                                    result = result()\r\n                                end\r\n                            end\r\n                            if result ~= watch.value then\r\n                                watch.value = result\r\n                                result = tostring(result)\r\n                                if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end\r\n                                if result:len() == 6 and watch.label:lower():find('guid') then result = console.format_guid(result) end\r\n                                printToColor(watch.label .. console.value_bb .. result .. '[-]', watch.player, console.output_color)\r\n                            end\r\n                        else\r\n                            if node ~= watch.value then\r\n                                watch.value = node\r\n                                if type(node) == 'boolean' then\r\n                                    if node then\r\n                                        node = 'true'\r\n                                    else\r\n                                        node = 'false'\r\n                                    end\r\n                                elseif type(node) == 'string' then\r\n                                    if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\\n', ' ') .. '...' end\r\n                                end\r\n                                printToColor(variable .. ': ' .. console.value_bb .. node .. '[-]', watch.player, console.output_color)\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    -- simple swear-blocking validation\r\n    console.add_validation_function(\r\n        function (message)\r\n            local message = message:lower()\r\n            for i, bad_word in pairs({'fuck', 'cunt'}) do\r\n                if message:find(bad_word) then\r\n                    return false, \"No swearing!\"\r\n                end\r\n            end\r\n            return true\r\n        end\r\n    )\r\n\r\n    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)\r\n\r\n\r\n    -- override default prompt with one which displays current table\r\n    function console.display_prompt(player)\r\n        printToColor(console.cd .. ' ' .. console.command_char..console.command_char, player.color, console.prompt_color)\r\n    end\r\n\r\n\r\n    -- console++ follows\r\n\r\n    console.cd = console.seperator\r\n    console.hidden_globals = {}\r\n    console.hide_globals(console.builtin_path)\r\n\r\n    function console.is_hidden(label)\r\n        for _, globals in pairs(console.hidden_globals) do\r\n            if globals[label] then\r\n                return true\r\n            end\r\n        end\r\n        return false\r\n    end\r\n\r\n    function console.escape_bb(s)\r\n        local s = tostring(s)\r\n        if s == '' then\r\n            return ''\r\n        else\r\n            local r = ''\r\n            for c = 1, s:len() do\r\n                local char = s:sub(c, c)\r\n                if char == '[' then\r\n                    r = r .. '[\\u{200B}'\r\n                elseif char == ']' then\r\n                    r = r .. '\\u{200B}]'\r\n                else\r\n                    r = r .. char\r\n                end\r\n            end\r\n            return r\r\n        end\r\n    end\r\n\r\n    function console.format_guid(guid)\r\n        return console.guid_bb .. '⁅' .. guid .. '⁆[-]'\r\n    end\r\n\r\n    function console.fill_path(path)\r\n        local path = path\r\n        local filter = nil\r\n        if path == nil then\r\n            return console.cd, filter\r\n        end\r\n        local c = path:len()\r\n        if path:sub(c) ~= console.seperator then\r\n            local found = false\r\n            while c > 0 do\r\n                local char = path:sub(c, c)\r\n                if char == console.wildcard then\r\n                    found = true\r\n                elseif char == console.seperator then\r\n                    break\r\n                end\r\n                c = c - 1\r\n            end\r\n            if found then\r\n                filter = '^'\r\n                for i = c + 1, path:len() do\r\n                    local char = path:sub(i, i)\r\n                    if char == console.wildcard then\r\n                        filter = filter .. '.*'\r\n                    else\r\n                        filter = filter .. char\r\n                    end\r\n                end\r\n                filter = filter .. '$'\r\n                path = path:sub(1, c)\r\n            end\r\n        end\r\n        if path:sub(1,1) == console.seperator then\r\n            return path, filter\r\n        else\r\n            return console.cd .. path, filter\r\n        end\r\n    end\r\n\r\n    function console.node_from_path(path)\r\n        local node = _G\r\n        local id = {''}\r\n        local parent = {nil}\r\n        local found = true\r\n        local depth = 0\r\n        local stack = {}\r\n        local hidden = nil\r\n        local ends_with_table = {true}\r\n        if path == 'true' then\r\n            node = true\r\n        elseif path == 'false' then\r\n            node = false\r\n        elseif path ~= console.seperator then\r\n            for i, part in ipairs(console.split(path, console.seperator)) do\r\n                if part == '..' then\r\n                    if depth > 0 then\r\n                        node = table.remove(parent)\r\n                        table.remove(id)\r\n                        table.remove(stack)\r\n                        table.remove(ends_with_table)\r\n                        depth = depth - 1\r\n                    end\r\n                elseif part == '.' then\r\n                    ; -- do nothing, . = where we are\r\n                elseif part == console.result then\r\n                    table.insert(parent, node)\r\n                    table.insert(id, part)\r\n                    table.insert(stack, part)\r\n                    node = console.returned_value\r\n                    table.insert(ends_with_table, type(node) == 'table')\r\n                    depth = depth + 1\r\n                elseif node[part] ~= nil then\r\n                    table.insert(parent, node)\r\n                    table.insert(id, part)\r\n                    table.insert(stack, part)\r\n                    node = node[part]\r\n                    table.insert(ends_with_table, type(node) == 'table')\r\n                    depth = depth + 1\r\n                elseif node == _G and console.hidden_globals[part] then\r\n                    hidden = console.hidden_globals[part]\r\n                else\r\n                    table.insert(id, part)\r\n                    found = false\r\n                    break\r\n                end\r\n            end\r\n        end\r\n        path = ''\r\n        for i, part in ipairs(stack) do\r\n            path = path .. console.seperator .. part\r\n        end\r\n        if table.remove(ends_with_table) then\r\n            path = path .. console.seperator\r\n        end\r\n        return node, table.remove(id), table.remove(parent), found, path, hidden\r\n    end\r\n\r\n\r\n    -- commands\r\n\r\n    console.add_admin_command('cd', '[<table>]',\r\n        'Display current table or change current table',\r\n        function (player, path)\r\n            if path == nil then\r\n                return console.cd\r\n            else\r\n                path = tostring(path)\r\n            end\r\n            local location = console.fill_path(path)\r\n            local node, id, parent, found, location = console.node_from_path(location)\r\n            local text = nil\r\n            if node ~= nil and found and type(node) == 'table' then\r\n                console.cd = location\r\n                if not console.in_command_mode[player.steam_id] then text = console.cd end\r\n            else\r\n                text = console.error_bb .. '<not found>[-]'\r\n            end\r\n            return text, false\r\n        end\r\n    )\r\n    console.add_admin_command('cd..', '', 'Change current table to parent table.', 'cd', {'..'})\r\n\r\n    console.add_admin_command('ls', '[' .. console.option .. '?afotv] [' .. console.option .. 'r[#]] [<table>]',\r\n        'Display variables in current table or specified table',\r\n        function (player, ...)\r\n            local help_details = console.header_bb .. 'Options[-]\\n' ..\r\n                'Show:\\n '..console.option..'f functions\\n '..console.option..'o objects\\n '..\r\n                console.option..'v variables (defaults to on)\\n '..console.option..'t tables (defaults to on)\\n '..\r\n                console.option..'a all\\n\\n' ..console.option..'r[#] recurse [# layers if specified]'\r\n            local path = console.cd\r\n            local display_functions = false\r\n            local display_objects = false\r\n            local display_variables = false\r\n            local display_tables = false\r\n            local display_all = false\r\n            local recursions_left = 0\r\n            for i, arg in ipairs({...}) do\r\n                arg = tostring(arg)\r\n                if arg:len() > 1 and arg:sub(1,1) == console.option then\r\n                    local c = 2\r\n                    while c <= arg:len() do\r\n                        local option = arg:sub(c,c)\r\n                        if option == 'f' then\r\n                            display_functions = not display_functions\r\n                        elseif option == 'o' then\r\n                            display_objects = not display_objects\r\n                        elseif option == 'v' then\r\n                            display_variables = not display_variables\r\n                        elseif option == 't' then\r\n                            display_tables = not display_tables\r\n                        elseif option == 'a' then\r\n                            display_all = not display_all\r\n                        elseif option == 'r' then\r\n                            local n = ''\r\n                            local j = c + 1\r\n                            while j <= arg:len() do\r\n                                local char = arg:sub(j, j)\r\n                                if char:match('%d') then\r\n                                    n = n .. char\r\n                                else\r\n                                    break\r\n                                end\r\n                                j = j + 1\r\n                            end\r\n                            c = j - 1\r\n                            if n == '' then\r\n                                recursions_left = 20\r\n                            else\r\n                                recursions_left = tonumber(n)\r\n                            end\r\n                        elseif option == '?' or option == 'h' then\r\n                            return help_details\r\n                        else\r\n                            return console.error_bb .. \"<option '\" .. console.option .. option .. \"' not recognized>[-]\\n\"\r\n                        end\r\n                        c = c + 1\r\n                    end\r\n                else\r\n                    path = arg\r\n                end\r\n            end\r\n            local default_variables = not (display_tables or display_objects or display_functions or display_variables)\r\n            if display_functions or display_objects or display_variables then\r\n                display_tables = not display_tables\r\n            end\r\n            if display_all then\r\n                display_functions = true\r\n                display_objects = true\r\n                display_variables = true\r\n                display_tables = true\r\n            elseif default_variables then\r\n                display_functions = false\r\n                display_objects = false\r\n                display_variables = true\r\n                display_tables = true\r\n            end\r\n            local location, filter = console.fill_path(path)\r\n            return console.ls(player, location, filter, display_functions, display_objects, display_variables, display_tables, recursions_left)\r\n        end\r\n    )\r\n    console.add_admin_command('dir', nil, nil, 'ls')\r\n    console.add_admin_command(console.result, '', \"Calls 'ls \"..console.option..\"a \"..console.result..\"'\", 'ls', {console.option..'a', console.result})\r\n\r\n    function console.ls(player, path, filter, display_functions, display_objects, display_variables, display_tables, recursions_left, indent)\r\n        local text = ''\r\n        local indent = indent or ''\r\n        local node, id, parent, found, location, hidden = console.node_from_path(path)\r\n        local paths = {}\r\n        if node ~= nil and (found or hidden) then\r\n            if type(node) == 'table' then\r\n                local tables = {}\r\n                local entries = {}\r\n                for k, v in pairs(node) do\r\n                    if (node ~= _G or (not hidden and not console.is_hidden(k)) or (hidden and hidden[k])) and (filter == nil or k:match(filter)) then\r\n                        if type(v) == 'table' then\r\n                            local t = console.table_bb .. k .. '[-]'\r\n                            table.insert(tables, t)\r\n                            paths[t] = path .. console.seperator .. k\r\n                        else\r\n                            if type(v) == 'function' then\r\n                                if display_functions then\r\n                                    table.insert(entries, console.function_bb .. k .. '[-]()')\r\n                                end\r\n                            elseif type(v) == 'userdata' then\r\n                                if display_objects then\r\n                                    local tag = tostring(v)\r\n                                    if tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then\r\n                                        tag = v.tag .. ' ' .. console.format_guid(v.getGUID())\r\n                                    end\r\n                                    if type(k) == 'number' and math.floor(k) == k then k = string.format('%04d', k) end\r\n                                    table.insert(entries, console.object_bb .. k .. '[-]: '  .. tag)\r\n                                end\r\n                            elseif display_variables then\r\n                                if type(v) == 'boolean' then\r\n                                    if v then\r\n                                        v = 'true'\r\n                                    else\r\n                                        v = 'false'\r\n                                    end\r\n                                    table.insert(entries, k .. ': ' .. console.boolean_bb .. v .. '[-]')\r\n                                else\r\n                                    local is_guid = false\r\n                                    if type(v) == 'string' then\r\n                                        if v:len()> console.crop_string_at then v = v:sub(1, console.crop_string_at):gsub('\\n', ' ') .. '...' end\r\n                                        if type(k) == 'string' and k:lower():find('guid') and v:len() == 6 then\r\n                                            is_guid = true\r\n                                        end\r\n                                    end\r\n                                    if is_guid then\r\n                                        table.insert(entries, k .. ': ' .. console.format_guid(v) .. '[-]')\r\n                                    else\r\n                                        table.insert(entries, k .. ': ' .. console.value_bb .. console.escape_bb(v) .. '[-]')\r\n                                    end\r\n                                end\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                local cmp = function (a, b)\r\n                    if not a then\r\n                        return true\r\n                    elseif not b then\r\n                        return false\r\n                    else\r\n                        local la = a:len()\r\n                        local lb = b:len()\r\n                        local c = 1\r\n                        repeat\r\n                            if c > la and c <= lb then\r\n                                return true\r\n                            elseif c > lb and c <= la then\r\n                                return false\r\n                            elseif c > la then\r\n                                return false\r\n                            else\r\n                                local ba = a:sub(c, c):byte()\r\n                                local bb = b:sub(c, c):byte()\r\n                                if ba < bb then\r\n                                    return true\r\n                                elseif bb < ba then\r\n                                    return false\r\n                                end\r\n                            end\r\n                            c = c + 1\r\n                        until false\r\n                    end\r\n                end\r\n                table.sort(tables, cmp)\r\n                table.sort(entries, cmp)\r\n                local cr = ''\r\n                if display_tables then\r\n                    for i, t in ipairs(tables) do\r\n                        text = text .. cr .. indent .. t .. console.seperator\r\n                        if recursions_left ~= 0 then\r\n                            text = text .. '\\n' .. console.ls(player, paths[t], filter,\r\n                                display_functions, display_objects, display_variables, display_tables,\r\n                                recursions_left-1, indent..console.indent)\r\n                        end\r\n                        cr = '\\n'\r\n                    end\r\n                    if node == _G and not hidden then\r\n                        for label, _ in pairs(console.hidden_globals) do\r\n                            if (filter == nil or label:match(filter)) then -- and label ~= console.builtin_path\r\n                                text = text .. cr .. indent .. console.hidden_bb .. label .. console.seperator .. '[-]'\r\n                                cr = '\\n'\r\n                            end\r\n                        end\r\n                    end\r\n                end\r\n                for _, entry in ipairs(entries) do\r\n                    text = text .. cr .. indent .. entry\r\n                    cr = '\\n'\r\n                end\r\n            elseif type(node) == 'userdata' then\r\n                local tag = tostring(node)\r\n                if tag ~= 'null' and tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then\r\n                    tag = node.tag .. ' ' .. console.format_guid(node.getGUID())\r\n                end\r\n                text = indent .. console.object_bb .. id .. '[-]: ' .. tag\r\n            elseif type(node) == 'function' then\r\n                text = indent .. console.function_bb .. id .. '[-]()'\r\n            elseif type(node) == 'boolean' then\r\n                if node then\r\n                    text = indent .. id .. ': ' .. console.boolean_bb .. 'true[-]'\r\n                else\r\n                    text = indent .. id .. ': ' .. console.boolean_bb .. 'false[-]'\r\n                end\r\n            else\r\n                if type(id) == 'string' and id:lower():find('guid') and type(node) == 'string' and node:len() == 6 then\r\n                    text = indent .. id .. ': ' .. console.format_guid(node) .. '[-]'\r\n                else\r\n                    text = indent .. id .. ': ' .. console.value_bb .. console.escape_bb(node) .. '[-]'\r\n                end\r\n            end\r\n        else\r\n            text = indent .. console.error_bb .. '<not found>[-]'\r\n        end\r\n        return text\r\n    end\r\n\r\n    console.add_admin_command('call', '<function> [<parameter>...]',\r\n        'Call function with parameters and display result.',\r\n        function (player, ...)\r\n            local path = nil\r\n            local parameters = {}\r\n            for i, arg in ipairs({...}) do\r\n                if i == 1 then\r\n                    path = tostring(arg)\r\n                else\r\n                    if type(arg) == 'string' then\r\n                        if arg:len() > 2 and arg:sub(1,1) == console.literal then\r\n                            arg = arg:sub(2)\r\n                        else\r\n                            local node, id, parent, found = console.node_from_path(console.fill_path(arg))\r\n                            if node ~= nil and found then\r\n                                arg = node\r\n                            end\r\n                        end\r\n                    end\r\n                    table.insert(parameters, arg)\r\n                end\r\n            end\r\n            if path == nil then\r\n                return console.error_bb .. '<you must supply a function>[-]'\r\n            end\r\n            local location = console.fill_path(path)\r\n            local node, id, parent, found, location = console.node_from_path(location)\r\n            local text = nil\r\n            if node ~= nil and found and type(node) == 'function' then\r\n                console.returned_value = node(unpack(parameters))\r\n                text = tostring(console.returned_value)\r\n                if console.deferred_assignment then\r\n                    local da = console.deferred_assignment\r\n                    if da.command == 'set' then\r\n                        if da.parent[da.id] ~= nil then\r\n                            if da.force or type(console.returned_value) == type(da.parent[da.id]) then\r\n                                da.parent[da.id] = console.returned_value\r\n                                text = text .. '\\n' .. console.header_bb .. \"<set '\" .. da.id .. \"'>[-]\"\r\n                            else\r\n                                text = text .. '\\n' .. console.error_bb .. \"<cannot set '\" .. da.id .. \"': it is of type '\" .. type(da.parent[da.id]) .. \"'>[-]\"\r\n                            end\r\n                        else\r\n                            text = text .. '\\n' .. console.error_bb .. \"<cannot set '\" .. da.id .. \"': it does not exist>[-]\"\r\n                        end\r\n                    elseif da.command == 'add' then\r\n                        if da.parent[da.id] == nil then\r\n                            da.parent[da.id] = console.returned_value\r\n                            text = text .. '\\n' .. console.header_bb .. \"<added '\" .. da.id .. \"'>[-]\"\r\n                        else\r\n                            text = text .. '\\n' .. \"<cannot add '\" .. da.id .. \"': it already exists>[-]\"\r\n                        end\r\n                    end\r\n                    console.deferred_assignment = nil\r\n                end\r\n            else\r\n                text = console.error_bb .. '<not found>[-]'\r\n            end\r\n            return text, false\r\n        end\r\n    )\r\n\r\n    console.add_admin_command('set', '['..console.option..'f] <variable> [<value>]',\r\n        \"Set variable to value.  If no value specified then the next value returned from 'call' is used.\\n\" ..\r\n            console.option ..'f  force overwrite ignoring type',\r\n        function (player, ...)\r\n            local variable = nil\r\n            local value = nil\r\n            local force = false\r\n            for _, arg in ipairs({...}) do\r\n                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1, 1) == console.option then\r\n                    local c = 2\r\n                    while c <= arg:len() do\r\n                        local option = arg:sub(c, c)\r\n                        if option == \"f\" then\r\n                            force = not force\r\n                        else\r\n                            return console.error_bb .. \"<option '\" .. option .. \"' not recognized>[-]\"\r\n                        end\r\n                        c = c + 1\r\n                    end\r\n                elseif variable == nil then\r\n                    variable = tostring(arg)\r\n                else\r\n                    value = arg\r\n                end\r\n            end\r\n            if variable == nil then\r\n                return console.error_bb .. '<you must supply a variable>[-]'\r\n            end\r\n            variable = console.fill_path(variable)\r\n            local node, id, parent, found = console.node_from_path(variable)\r\n            local text = ''\r\n            if node ~= nil and found then\r\n                if value == nil then\r\n                    console.deferred_assignment = {command = 'set', parent = parent, id = id, force = force}\r\n                    text = id .. ': ' .. console.header_bb .. \"<awaiting 'call'>[-]\"\r\n                else\r\n                    console.deferred_assignment = nil\r\n                    if type(value) == 'string' and value:len() > 0  then\r\n                        if value:sub(1, 1) == console.literal then\r\n                            value = value:sub(2)\r\n                        else\r\n                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)\r\n                            if value_node ~= nil and value_found then\r\n                                value = value_node\r\n                            else\r\n                                return console.error_bb .. '<not found>[-]'\r\n                            end\r\n                        end\r\n                    end\r\n                    if type(node) == 'boolean' then\r\n                        if not value or tostring(value):lower() == 'false' then\r\n                            value = false\r\n                        else\r\n                            value = true\r\n                        end\r\n                    end\r\n                    if type(node) == type(value) or force then\r\n                        parent[id] = value\r\n                        text = id .. ': ' .. console.value_bb .. tostring(parent[id]) .. '[-]'\r\n                    else\r\n                        return console.error_bb .. \"<cannot set '\" .. id .. \"': it is of type '\" .. type(node) .. \"'>[-]\"\r\n                    end\r\n                end\r\n            else\r\n                text = console.error_bb .. '<not found>[-]'\r\n            end\r\n            return text\r\n        end\r\n    )\r\n\r\n    console.add_admin_command('toggle', '<boolean>',\r\n        'Toggle specified boolean variable',\r\n        function (player, variable)\r\n            if variable == nil then\r\n                return console.error_bb .. '<you must supply variable>'\r\n            else\r\n                variable = tostring(variable)\r\n            end\r\n            local variable = console.fill_path(variable)\r\n            local node, id, parent, found = console.node_from_path(variable)\r\n            local text = ''\r\n            if node ~= nil and found then\r\n                if type(node) == 'boolean' then\r\n                    if node then\r\n                        parent[id] = false\r\n                        text = id .. ': ' .. console.value_bb .. 'false[-]'\r\n                    else\r\n                        parent[id] = true\r\n                        text = id .. ': ' .. console.value_bb .. 'true[-]'\r\n                    end\r\n                else\r\n                    text = console.error_bb .. '<can only toggle a boolean>[-]'\r\n                end\r\n            else\r\n                text = console.error_bb .. '<not found>[-]'\r\n            end\r\n            return text\r\n        end\r\n    )\r\n    console.add_admin_command('tgl', nil, nil, 'toggle')\r\n\r\n    console.add_admin_command('rm', '<variable>',\r\n        'Remove specified variable',\r\n        function (player, variable)\r\n            if variable == nil then\r\n                return console.error_bb .. '<you must supply variable>'\r\n            else\r\n                variable = tostring(variable)\r\n            end\r\n            local variable = console.fill_path(variable)\r\n            local node, id, parent, found = console.node_from_path(variable)\r\n            local text = ''\r\n            if node ~= nil and found then\r\n                parent[id] = nil\r\n                text = id .. \" removed!\"\r\n            else\r\n                text = console.error_bb .. '<not found>[-]'\r\n            end\r\n            return text\r\n        end\r\n    )\r\n    console.add_admin_command('del', nil, nil, 'rm')\r\n\r\n    console.add_admin_command('add', '<variable> [<value>]',\r\n        \"Create a variable set to value.   If no value specified then the next value returned from 'call' is used.\",\r\n        function (player, variable, value)\r\n            if variable == nil then\r\n                return console.error_bb .. '<you must supply variable>[-]'\r\n            else\r\n                variable = tostring(variable)\r\n            end\r\n            local variable = console.fill_path(variable)\r\n            local node, id, parent, found = console.node_from_path(variable)\r\n            local text = ''\r\n            if found then\r\n                return console.error_bb .. '<already exists>[-]'\r\n            elseif node == nil or id == '' then\r\n                return console.error_bb .. '<not found>[-]'\r\n            else\r\n                if value == nil then\r\n                    console.deferred_assignment = {command = 'add', parent = node, id = id}\r\n                    text = id .. ': ' .. console.header_bb .. \"<awaiting 'call'>[-]\"\r\n                else\r\n                    console.deferred_assignment = nil\r\n                    if type(value) == 'string' and value:len() > 0  then\r\n                        if value:sub(1, 1) == console.literal then\r\n                            value = value:sub(2)\r\n                        else\r\n                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)\r\n                            if value_node ~= nil and value_found then\r\n                                value = value_node\r\n                            else\r\n                                return console.error_bb .. '<not found>[-]'\r\n                            end\r\n                        end\r\n                    end\r\n                    node[id] = value\r\n                    text = id .. ': ' .. console.value_bb .. tostring(value) .. '[-]'\r\n                end\r\n            end\r\n            return text\r\n        end\r\n    )\r\n\r\n    console.add_admin_command('exec', '['..console.option..'?qsv] <commands>',\r\n        'Execute a series of commands held in a string: commands are seperated by a new line or '..console.command_seperator,\r\n        function (player, ...)\r\n            local help_details = console.option..'q    quiet: will not output anything except final output\\n' ..\r\n                                 console.option..'s    silent: will not output anything at all\\n'..\r\n                                 console.option..'v    verbose: will output commands as they execute\\n'\r\n            local commands = nil\r\n            local verbose = false\r\n            local quiet = false\r\n            local silent = false\r\n            for _, arg in ipairs({...}) do\r\n                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then\r\n                    local c = 2\r\n                    while c <= arg:len() do\r\n                        local option = arg:sub(c,c)\r\n                        if option == '?' then\r\n                            return help_details\r\n                        elseif option == 'q' then\r\n                            quiet = not quiet\r\n                        elseif option == 's' then\r\n                            silent = not silent\r\n                        elseif option == 'v' then\r\n                            verbose = not verbose\r\n                        else\r\n                            return console.error_bb .. \"<option '\" .. option .. \"' not recognized>\"\r\n                        end\r\n                        c = c + 1\r\n                    end\r\n                elseif commands == nil then\r\n                    commands = tostring(arg)\r\n                end\r\n            end\r\n            if silent then quiet = true end\r\n            if commands:len() > 1 and commands:sub(1, 1) == console.literal then\r\n                commands = commands:sub(2)\r\n            else\r\n                local variable = console.fill_path(commands)\r\n                local node, id, parent, found = console.node_from_path(variable)\r\n                if node ~= nil and found then\r\n                    commands = node\r\n                else\r\n                    return console.error_bb .. '<not found>[-]'\r\n                end\r\n            end\r\n            if commands:find('\\n') then\r\n                commands = console.split(commands, '\\n')\r\n            else\r\n                commands = console.split(commands, console.command_seperator)\r\n            end\r\n            local end_result = nil\r\n            for _, command_text in ipairs(commands) do\r\n                local command = ''\r\n                local command_function = nil\r\n                local parameters = {player}\r\n                local requires_admin = false\r\n                command, command_function, parameters, requires_admin = console.get_command(command_text, player)\r\n                if command ~= '' then\r\n                    if command_function and (player.admin or not requires_admin) then\r\n                        local response, mute = command_function(unpack(parameters))\r\n                        if response ~= nil or mute ~= nil then\r\n                            if not mute and verbose and not quiet then\r\n                                printToColor('\\n'..command_text, player.color, console.command_color)\r\n                            end\r\n                            if response then\r\n                                end_result = response\r\n                                if not quiet then\r\n                                    printToColor(response, player.color, console.output_color)\r\n                                end\r\n                            end\r\n                        end\r\n                    elseif not quiet then\r\n                        if verbose then printToColor('\\n'..command_text, player.color, console.command_color) end\r\n                        printToColor(console.error_bb .. \"<command '\" .. command .. \"' not found>[-]\", player.color, console.output_color)\r\n                    end\r\n                end\r\n            end\r\n            if end_result and not silent then\r\n                printToColor(end_result, player.color, console.output_color)\r\n            end\r\n        end\r\n    )\r\n\r\n    console.add_admin_command('watch', '['..console.option..'?cgp] ['..console.option..'t#] ['..console.option..console.seperator..'<property>] [<variable>]',\r\n        'Watch a variable or object and display it whenever it changes.\\n' .. console.hidden_bb ..\r\n        'Requires you to add a '..console.function_bb..'console.update()[-] call to an ' ..\r\n        console.function_bb .. 'onUpdate[-] event in your code.[-]\\n',\r\n        function (player, ...)\r\n            local help_details = 'Call without a parameter to display watched items, or with a variable to add it to watch list.\\n' ..\r\n                                console.option..'c will clear variable if specified, or all.\\n' ..\r\n                                console.option..'g will let you specify an object by its GUID.\\n' ..\r\n                                console.option..'t# will throttle output to # seconds.\\n' ..\r\n                                console.option..console.seperator..'<property> will watch the property of the variable.\\n' ..\r\n                                console.option..'p will pause or unpause watching.\\n'\r\n            local path = nil\r\n            local clearing = false\r\n            local throttle = nil\r\n            local pause_changed = false\r\n            local by_guid = false\r\n            local parameters = {}\r\n            local labels = {}\r\n            local property = nil\r\n            for _, arg in ipairs({...}) do\r\n                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then\r\n                    local c = 2\r\n                    while c <= arg:len() do\r\n                        local option = arg:sub(c,c)\r\n                        if option == '?' then\r\n                            return help_details\r\n                        elseif option == 'c' then\r\n                            clearing = not clearing\r\n                        elseif option == 'p' then\r\n                            pause_changed = not pause_changed\r\n                        elseif option == 'g' then\r\n                            by_guid = not by_guid\r\n                        elseif option == console.seperator then\r\n                            if arg:len() > c then\r\n                                property = arg:sub(c + 1)\r\n                                c = arg:len() + 1\r\n                            end\r\n                        elseif option == 't' then\r\n                            local n = ''\r\n                            local j = c + 1\r\n                            while j <= arg:len() do\r\n                                local char = arg:sub(j, j)\r\n                                if char:match('[0-9.]') then\r\n                                    n = n .. char\r\n                                else\r\n                                    break\r\n                                end\r\n                                j = j + 1\r\n                            end\r\n                            c = j - 1\r\n                            if n == '' then\r\n                                return console.error_bb .. '<you must provide a throttle duration (in seconds)>[-]'\r\n                            else\r\n                                throttle = tonumber(n)\r\n                            end\r\n                        else\r\n                            return console.error_bb .. \"<option '\" .. option .. \"' not recognized>\"\r\n                        end\r\n                        c = c + 1\r\n                    end\r\n                else\r\n                    if path == nil then\r\n                        path = tostring(arg)\r\n                    else\r\n                        local label = tostring(arg)\r\n                        if type(arg) == 'string' then\r\n                            if arg:len() > 2 and arg:sub(1,1) == console.literal then\r\n                                arg = arg:sub(2)\r\n                                label = arg\r\n                            else\r\n                                local node, id, parent, found = console.node_from_path(console.fill_path(arg))\r\n                                if node ~= nil and found then\r\n                                    arg = node\r\n                                end\r\n                            end\r\n                        end\r\n                        table.insert(labels, label)\r\n                        table.insert(parameters, arg)\r\n                    end\r\n                end\r\n            end\r\n            local text = ''\r\n            if pause_changed then\r\n                if console.watch_list_paused then\r\n                    console.watch_list_paused = nil\r\n                    text = text .. console.header_bb .. '<unpaused>[-]'\r\n                else\r\n                    console.watch_list_paused = true\r\n                    text = text .. console.header_bb .. '<paused>[-]'\r\n                end\r\n            end\r\n            if path == nil then\r\n                if throttle ~= nil then\r\n                    text = text .. '\\n' .. console.error_bb .. '<you must provide a variable or object>[-]'\r\n                elseif by_guid then\r\n                    text = text .. '\\n' .. console.error_bb .. '<you must provide a GUID>[-]'\r\n                elseif clearing then\r\n                    console.watch_list = nil\r\n                    console.watch_list_paused = nil\r\n                    text = text .. '\\nWatch list cleared!'\r\n                elseif not pause_changed then\r\n                    if console.watch_list then\r\n                        local watched = {}\r\n                        for label, watch in pairs(console.watch_list) do\r\n                            if watch.player == player.color then\r\n                                table.insert(watched, label)\r\n                            end\r\n                        end\r\n                        table.sort(watched)\r\n                        text = text .. '\\n'..console.header_bb..'Watching:[-]'\r\n                        for _, label in ipairs(watched) do\r\n                            local watch = console.watch_list[label]\r\n                            local is_guid = (label:len() == 6 and label:sub(1,1) ~= console.seperator)\r\n                            local node, id, parent, found\r\n                            local prefix\r\n                            text = text .. '\\n'\r\n                            if is_guid then\r\n                                prefix =  console.format_guid(label)\r\n                                node = getObjectFromGUID(label)\r\n                                found = tostring(node) ~= 'null'\r\n                            else\r\n                                prefix = label\r\n                                node, id, parent, found = console.node_from_path(label)\r\n                            end\r\n                            if node ~= nil and found then\r\n                                if type(node) == 'userdata' then\r\n                                    prefix = console.object_bb .. prefix .. '[-]'\r\n                                    local position = node.getPosition()\r\n                                    local rotation = node.getRotation()\r\n                                    local p = function (x) return math.floor(x * 100) * 0.01 end\r\n                                    local r = function (x) return math.floor(x + 0.5) end\r\n                                    text = text .. prefix .. console.value_bb .. ' ∡ '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) .. '[-]'..\r\n                                            console.boolean_bb..'   ⊞  '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)\r\n                                elseif type(node) == 'function' then\r\n                                    local result = node(unpack(console.watch_list[label].parameters))\r\n                                    if watch.property and (type(result) == 'table' or type(result) == 'userdata') then\r\n                                        result = result[watch.property]\r\n                                        if type(result) == 'function' then\r\n                                            result = result()\r\n                                        end\r\n                                    end\r\n                                    result = tostring(result)\r\n                                    if watch.propery and watch.property:lower():find('guid') then\r\n                                        result = console.format_guid(result)\r\n                                    end\r\n                                    if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end\r\n                                    text = text .. watch.label .. console.value_bb .. result .. '[-]'\r\n                                else\r\n                                    if type(node) == 'boolean' then\r\n                                        if node then\r\n                                            node = 'true'\r\n                                        else\r\n                                            node = 'false'\r\n                                        end\r\n                                    elseif type(node) == 'string' then\r\n                                        if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\\n', ' ') .. '...' end\r\n                                    end\r\n                                    text = text .. prefix .. ': ' .. console.value_bb .. node .. '[-]'\r\n                                end\r\n                            end\r\n                        end\r\n                    else\r\n                        text = text .. \"\\nWatch list is empty.\"\r\n                    end\r\n                end\r\n            else\r\n                if not by_guid then\r\n                    path = console.fill_path(path)\r\n                end\r\n                if clearing then\r\n                    local node, id, parent, found\r\n                    if not by_guid then\r\n                        node, id, parent, found, path = console.node_from_path(path)\r\n                    end\r\n                    if console.watch_list[path] then\r\n                        console.watch_list[path] = nil\r\n                        if next(console.watch_list) == nil then\r\n                            console.watch_list = nil\r\n                        end\r\n                        text = text .. '\\n' .. console.header_bb.. 'No longer watching:[-] ' .. path\r\n                    else\r\n                        text = text .. '\\n' .. console.error_bb .. '<not found>[-]'\r\n                    end\r\n                else\r\n                    local node, id, parent, found\r\n                    if by_guid then\r\n                        node = getObjectFromGUID(path)\r\n                        found = tostring(node) ~= 'null'\r\n                    else\r\n                        node, id, parent, found, path = console.node_from_path(path)\r\n                    end\r\n                    if node ~= nil and found then\r\n                        if console.watch_list == nil then console.watch_list = {} end\r\n                        if throttle == nil then throttle = 0 end\r\n                        console.watch_list[path] = {player=player.color, throttle=throttle, last_check=0, property=property}\r\n                        if type(node) == 'userdata' then\r\n                            console.watch_list[path].position = node.getPosition()\r\n                            console.watch_list[path].rotation = node.getRotation()\r\n                            console.watch_list[path].is_guid  = by_guid\r\n                        elseif type(node) == 'function' then\r\n                            console.watch_list[path].parameters = parameters\r\n                            console.watch_list[path].value = node\r\n                            console.watch_list[path].label = console.function_bb .. path .. '[-]'\r\n                            if property then\r\n                                console.watch_list[path].label = console.watch_list[path].label .. console.seperator .. property\r\n                            end\r\n                            for _, label in ipairs(labels) do\r\n                                console.watch_list[path].label = console.watch_list[path].label .. ' ' .. console.hidden_bb .. label .. '[-]'\r\n                            end\r\n                            console.watch_list[path].label = console.watch_list[path].label .. ': '\r\n                        else\r\n                            console.watch_list[path].value = node\r\n                        end\r\n                        if by_guid then\r\n                            path = console.format_guid(path)\r\n                        end\r\n                        text = text .. '\\n' .. console.header_bb .. 'Watching:[-] ' .. path\r\n                    else\r\n                        text = text .. '\\n' .. console.error_bb .. '<not found>[-]'\r\n                    end\r\n                end\r\n            end\r\n            if text:len() > 1 and text:sub(1, 1) == '\\n' then\r\n                text = text:sub(2)\r\n            end\r\n            return text\r\n        end\r\n    )\r\n\r\n    console.add_player_command('shout', '<text>',\r\n        'Broadcast <text> to all players. Colour a section with {RRGGBB}section{-}.',\r\n        function (player, ...)\r\n            local text = player.steam_name .. ': '\r\n            local space = ''\r\n            for _, word in ipairs({...}) do\r\n                text = text .. space .. tostring(word)\r\n                space = ' '\r\n            end\r\n            text = text:gsub('{','[')\r\n            text = text:gsub('}',']')\r\n            broadcastToAll(text, stringColorToRGB(player.color))\r\n            return nil, false\r\n        end\r\n    )\r\n\r\n    -- change the command help color so client added commands appear different to console++\r\n    console.set_command_listing_bb('[A0F0C0]')\r\nend\r\n\r\nend)\r\n__bundle_register(\"Console/console\", function(require, _LOADED, __bundle_register, __bundle_modules)\r\nif not console then\r\n    console = {}\r\n\r\n    -- Change these values as you wish\r\n    console.command_char = '>'\r\n    console.option       = '-'\r\n    console.prompt_color  = {r = 0.8,  g = 1.0,  b = 0.8 }\r\n    console.command_color = {r = 0.8,  g = 0.6,  b = 0.8 }\r\n    console.output_color  = {r = 0.88, g = 0.88, b = 0.88}\r\n    console.invalid_color = {r = 1.0,  g = 0.2,  b = 0.2 }\r\n    console.header_bb       = '[EECCAA]'\r\n    console.error_bb        = '[FF9999]'\r\n    console.inbuilt_help_bb = '[E0E0E0]'\r\n    console.client_help_bb  = '[C0C0FF]'\r\n\r\n    -- Exposed methods:\r\n\r\n    function console.add_validation_function(validation_function)\r\n        -- Adds a validation function all chat will be checked against:\r\n        -- function(string message) which returns (boolean valid, string response)\r\n        -- If all validation functions return <valid> as true the message will be displayed.\r\n        -- If one returns <valid> as false then its <response> will be displayed to that player instead.\r\n        table.insert(console.validation_functions, validation_function)\r\n    end\r\n\r\n    function console.add_player_command(command, parameter_text, help_text, command_function, default_parameters)\r\n        -- Adds a command anyone can use, see below for details\r\n        console.add_command(command, false, parameter_text, help_text, command_function, default_parameters)\r\n    end\r\n\r\n    function console.add_admin_command(command, parameter_text, help_text, command_function, default_parameters)\r\n        -- Adds a command only admins can use, see below for details\r\n        console.add_command(command, true, parameter_text, help_text, command_function, default_parameters)\r\n    end\r\n\r\n    function console.add_command(command, requires_admin, parameter_text, help_text, command_function, default_parameters)\r\n        -- Adds a command to the console.\r\n        -- command_function must take <player> as its first argument, and then any\r\n        --   subsequent arguments you wish which will be provided by the player.\r\n        -- You may alias an already-present command by calling this with command_function set to\r\n        --   the command string instead of a function.  default_parameters can be set for the alias.\r\n        -- See basic built-in commands at the bottom of this file for examples.\r\n        local commands = console.commands\r\n        local command_function = command_function\r\n        local help_text = help_text\r\n        local parameter_text = parameter_text\r\n        if type(command_function) == 'string' then --alias\r\n            if help_text == nil then\r\n                help_text = commands[command_function].help_text\r\n            end\r\n            if parameter_text == nil then\r\n                parameter_text = commands[command_function].parameter_text\r\n            end\r\n            command_function = commands[command_function].command_function\r\n        end\r\n        console.commands[command] = {\r\n            command_function   = command_function,\r\n            requires_admin     = requires_admin,\r\n            parameter_text     = parameter_text,\r\n            help_text          = help_text,\r\n            help_bb            = console.command_help_bb,\r\n            default_parameters = default_parameters,\r\n        }\r\n    end\r\n\r\n    function console.set_command_listing_bb(bb)\r\n        -- Tags commands added after with a bb color for when they are displayed (i.e. with 'help')\r\n        console.command_help_bb = bb\r\n    end\r\n\r\n    function console.disable()\r\n        -- Disables console for command purposes, but leaves validation functions running\r\n        console.active = false\r\n    end\r\n\r\n    function console.enable()\r\n        -- Enables console commands (console commands are on by default)\r\n        console.active = true\r\n    end\r\n\r\n    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)\r\n\r\n\r\n    console.active = true\r\n    console.in_command_mode = {}\r\n    console.commands = {}\r\n    console.validation_functions = {}\r\n    console.set_command_listing_bb(console.inbuilt_help_bb)\r\n\r\n    function onChat(message, player)\r\n        if message ~= '' then\r\n            local command = ''\r\n            local command_function = nil\r\n            local parameters = {player}\r\n            local requires_admin = false\r\n            local command_mode = console.in_command_mode[player.steam_id]\r\n            if command_mode and console.active then\r\n                command, command_function, parameters, requires_admin = console.get_command(message, player)\r\n            elseif message:sub(1, 1) == console.command_char and console.active then\r\n                if message:len() > 1 then\r\n                    command, command_function, parameters, requires_admin = console.get_command(message:sub(2), player)\r\n                else\r\n                    command, command_function, parameters, requires_admin = console.get_command(console.command_char, player)\r\n                end\r\n            else\r\n                for i, f in ipairs(console.validation_functions) do\r\n                    local valid, response = f(message)\r\n                    if response == nil then response = '' end\r\n                    if not valid then\r\n                        printToColor(response, player.color, console.invalid_color)\r\n                        return false\r\n                    end\r\n                end\r\n                return true\r\n            end\r\n            if console.active then\r\n                if command_function and (player.admin or not requires_admin) then\r\n                    if command_mode then\r\n                        message = console.command_char .. console.command_char .. message\r\n                    end\r\n                    local response, mute = command_function(unpack(parameters))\r\n                    if response ~= nil or mute ~= nil then\r\n                        if not mute then\r\n                            printToColor('\\n'..message, player.color, console.command_color)\r\n                        end\r\n                        if response then\r\n                            printToColor(response, player.color, console.output_color)\r\n                        end\r\n                    end\r\n                    if console.in_command_mode[player.steam_id] then console.display_prompt(player) end\r\n                    return false\r\n                else\r\n                    printToColor('\\n'..message, player.color, console.command_color)\r\n                    printToColor(console.error_bb .. \"<command '\" .. command .. \"' not found>[-]\", player.color, console.output_color)\r\n                    return false\r\n                end\r\n            end\r\n        end\r\n    end\r\n\r\n    function console.get_command(message, player)\r\n        local command_name = ''\r\n        local command_function = nil\r\n        local requires_admin = false\r\n        local parameters = {player}\r\n        for i, part in ipairs(console.split(message)) do\r\n            if i == 1 then\r\n                command_name = part\r\n                local command = console.commands[command_name]\r\n                if command then\r\n                    command_function = command.command_function\r\n                    requires_admin = command.requires_admin\r\n                    if command.default_parameters then\r\n                        for _, parameter in ipairs(command.default_parameters) do\r\n                            table.insert(parameters, parameter)\r\n                        end\r\n                    end\r\n                end\r\n            else\r\n                table.insert(parameters, part)\r\n            end\r\n        end\r\n        return command_name, command_function, parameters, requires_admin\r\n    end\r\n\r\n    function console.display_prompt(player)\r\n        printToColor(console.command_char..console.command_char, player.color, console.prompt_color)\r\n    end\r\n\r\n    function console.split(text, split_on)\r\n        local split_on = split_on or ' '\r\n        if type(split_on) == 'string' then\r\n            local s = {}\r\n            for c = 1, split_on:len() do\r\n                s[split_on:sub(c,c)] = true\r\n            end\r\n            split_on = s\r\n        end\r\n        local parts = {}\r\n        if text ~= '' then\r\n            local make_table = function(s)\r\n                local entries = console.split(s, ' ,')\r\n                local t = {}\r\n                for _, entry in ipairs(entries) do\r\n                    if type(entry) == 'string' and entry:find('=') then\r\n                        e = console.split(entry, '=')\r\n                        t[e[1]] = e[2]\r\n                    else\r\n                        table.insert(t, entry)\r\n                    end\r\n                end\r\n                return t\r\n            end\r\n            local current_split_on = split_on\r\n            local adding = false\r\n            local part = \"\"\r\n            local totype = tonumber\r\n            for c = 1, text:len() do\r\n                local char = text:sub(c, c)\r\n                if adding then\r\n                    if current_split_on[char] then -- ended current part\r\n                        if totype(part) ~= nil then\r\n                            table.insert(parts, totype(part))\r\n                        else\r\n                            table.insert(parts, part)\r\n                        end\r\n                        adding = false\r\n                        current_split_on = split_on\r\n                        totype = tonumber\r\n                    else\r\n                        part = part .. char\r\n                    end\r\n                else\r\n                    if not current_split_on[char] then -- found start of part\r\n                        if char == \"'\" then\r\n                            current_split_on = {[\"'\"] = true}\r\n                            totype = tostring\r\n                            part = ''\r\n                        elseif char == '\"' then\r\n                            current_split_on = {['\"'] = true}\r\n                            totype = tostring\r\n                            part = ''\r\n                        elseif char == '{' then\r\n                            current_split_on = {['}'] = true}\r\n                            totype = make_table\r\n                            part = ''\r\n                        else\r\n                            part = char\r\n                        end\r\n                        adding = true\r\n                    end\r\n                end\r\n            end\r\n            if adding then\r\n                if totype(part) ~= nil then\r\n                    table.insert(parts, totype(part))\r\n                else\r\n                    table.insert(parts, part)\r\n                end\r\n            end\r\n        end\r\n        return parts\r\n    end\r\n\r\n\r\n    -- Add basic built-in console commands\r\n\r\n    console.add_player_command('help', '[' .. console.option .. 'all|<command>]',\r\n        'Display available commands or help on all commands or help on a specific command.',\r\n        function (player, command)\r\n            if command ~= nil then\r\n                command = tostring(command)\r\n            end\r\n            local make_help = function (command)\r\n                return console.header_bb .. command .. ' ' .. console.commands[command].parameter_text ..\r\n                        '[-]\\n' .. console.commands[command].help_text\r\n            end\r\n            local info_mode = false\r\n            if command == console.option..'all' then\r\n                info_mode = true\r\n            end\r\n            if command and console.commands[command] then\r\n                return make_help(command)\r\n            elseif command and not info_mode then\r\n                return console.error_bb .. \"<command '\" .. command .. \"' not found>[-]\"\r\n            else\r\n                local msg = console.header_bb .. 'Available commands:[-]'\r\n                local command_list = {}\r\n                for c, _ in pairs(console.commands) do\r\n                    if player.admin or not console.commands[c].requires_admin then\r\n                        if info_mode then\r\n                            table.insert(command_list, make_help(c))\r\n                        else\r\n                            table.insert(command_list, c)\r\n                        end\r\n                    end\r\n                end\r\n                table.sort(command_list)\r\n                local sep\r\n                if info_mode then\r\n                    sep = '\\n\\n'\r\n                else\r\n                    sep = '\\n'\r\n                end\r\n                for _, c in ipairs(command_list) do\r\n                    local cmd = console.commands[c]\r\n                    if cmd then\r\n                        msg = msg .. sep .. cmd.help_bb .. c .. '[-]'\r\n                    else\r\n                        msg = msg .. sep .. c\r\n                    end\r\n                    if not info_mode then sep = ', ' end\r\n                end\r\n                return msg\r\n            end\r\n        end\r\n    )\r\n    console.add_player_command('?', nil, nil, 'help')\r\n    console.add_player_command('info', '', 'Display help on all available commands.', 'help', {console.option..'all'})\r\n\r\n    console.add_player_command('exit', '',\r\n        \"Leave <command mode> ('\" .. console.command_char .. \"' does the same).\",\r\n        function (player)\r\n            console.in_command_mode[player.steam_id] = nil\r\n            return console.header_bb .. '<command mode: off>[-]'\r\n        end\r\n    )\r\n\r\n    console.add_player_command('cmd', '',\r\n        \"Enter <command mode> ('\" .. console.command_char .. \"' does the same).\",\r\n        function (player)\r\n            console.in_command_mode[player.steam_id] = true\r\n            return console.header_bb .. '<command mode: on>[-]'\r\n        end\r\n    )\r\n\r\n    console.add_player_command(console.command_char, '',\r\n        'Toggle <command mode>',\r\n        function (player)\r\n            console.in_command_mode[player.steam_id] = not console.in_command_mode[player.steam_id]\r\n            if console.in_command_mode[player.steam_id] then\r\n                return console.header_bb .. '<command mode: on>[-]', true\r\n            else\r\n                return console.header_bb .. '<command mode: off>[-]', true\r\n            end\r\n        end\r\n    )\r\n\r\n    console.add_player_command('=', '<expression>',\r\n        'Evaluate an expression',\r\n        function (player, ...)\r\n            local expression = ''\r\n            for _, arg in ipairs({...}) do\r\n                expression = expression .. ' ' .. tostring(arg)\r\n            end\r\n            if not player.admin then\r\n                expression = expression:gasub('[a-zA-Z~]', '')\r\n            end\r\n            console.returned_value = dynamic.eval(expression)\r\n            return console.returned_value\r\n        end\r\n    )\r\n\r\n    console.add_player_command('echo', '<text>',\r\n        'Display text on screen',\r\n        function (player, ...)\r\n            local text = ''\r\n            for _, arg in ipairs({...}) do\r\n                text = text .. ' ' .. tostring(arg)\r\n            end\r\n            printToColor(text, player.color, console.output_color)\r\n            return false\r\n        end\r\n    )\r\n\r\n    console.add_player_command('cls', '',\r\n        'Clear console text',\r\n        function (player)\r\n            return '\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n' ..\r\n                   '\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n'\r\n        end\r\n    )\r\n\r\n    console.add_player_command('alias', '<alias> <command> [<parameter>...]',\r\n        'Create a command alias.',\r\n        function (player, ...)\r\n            local alias\r\n            local command\r\n            local parameters = {}\r\n            for i, arg in ipairs({...}) do\r\n                if i == 1 then\r\n                    alias = tostring(arg)\r\n                elseif i == 2 then\r\n                    command = tostring(arg)\r\n                else\r\n                    table.insert(parameters, arg)\r\n                end\r\n            end\r\n            if not alias then\r\n                return console.error_bb .. '<must provide an alias>[-]'\r\n            --elseif console.commands[alias] ~= nil then\r\n            --    return console.error_bb .. \"<command '\" .. alias .. \"' already exists!>[-]\"\r\n            elseif command == nil then\r\n                return console.error_bb .. \"<must provide a command>[-]\"\r\n            elseif console.commands[command] == nil then\r\n                return console.error_bb .. \"<command '\" .. command .. \"' does not exist>[-]\"\r\n            else\r\n                local text = console.header_bb .. alias .. '[-] = ' .. command\r\n                local help_text = console.commands[command].help_text\r\n                if not help_text:find('\\nAliased to: ') then\r\n                    help_text = help_text .. '\\nAliased to: ' .. command\r\n                end\r\n                local combined_parameters = {}\r\n                if console.commands[command].default_parameters then\r\n                    for _, parameter in ipairs(console.commands[command].default_parameters) do\r\n                        table.insert(combined_parameters, parameter)\r\n                    end\r\n                end\r\n                for _, parameter in ipairs(parameters) do\r\n                    table.insert(combined_parameters, parameter)\r\n                    text = text .. ' ' .. parameter\r\n                    help_text = help_text .. ' ' .. parameter\r\n                end\r\n                console.add_command(alias, console.commands[command].requires_admin, console.commands[command].parameter_text, help_text, command, combined_parameters)\r\n                return text\r\n            end\r\n        end\r\n    )\r\n\r\n    -- change the command help color so client added commands appear different to in-built\r\n    console.set_command_listing_bb(console.client_help_bb)\r\nend\r\n\r\nend)\r\nreturn __bundle_require(\"Yellow Machine.46ccee.lua\")",
      "LuaScriptState": "",
      "XmlUI": "<Defaults>\r\n    <Button class=\"unassignedWeapon\" fontSize=\"18\" />\r\n    <Text class=\"ym-resizing20Bold\" fontStyle=\"Bold\" fontSize=\"20\" />\r\n    <HorizontalLayout childForceExpandHeight=\"false\" childForceExpandWidth=\"false\" childAlignment=\"MiddleCenter\" />\r\n    <Panel class=\"mainWindow\" height=\"700\" width=\"1200\" color=\"#e1e9a5\" childAlignment=\"MiddleCenter\" />\r\n    <Panel class=\"hiddenBigWindow\" color=\"#ffffff00\" height=\"4000\" childForceExpandHeight=\"false\" />\r\n    <VerticalLayout class=\"panelContainer\" childForceExpandHeight=\"false\" childForceExpandWidth=\"false\" childAlignment=\"MiddleCenter\"\r\n                    showAnimation=\"FadeIn\" hideAnimation=\"FadeOut\" animationDuration=\"0.2\" />\r\n    <VerticalLayout class=\"transparent\" color=\"#ffffff00\" />\r\n    <VerticalLayout class=\"modelContainer\" shadow=\"Black\" childForceExpandWidth=\"false\" preferredWidth=\"400\" onClick=\"selectModelGroup\" padding=\"10\" color=\"White\" onMouseEnter=\"showAssociatedModel\" onMouseExit=\"hideAssociatedModel\" />\r\n    <Text alignment=\"UpperLeft\" />\r\n    <Text class=\"smallText\" fontSize=\"18\" horizontalOverflow=\"Overflow\" />\r\n    <Text class=\"unitName\" color=\"White\" fontSize=\"48\" alignment=\"MiddleCenter\" resizeTextForBestFit=\"true\" resizeTextMaxSize=\"48\" />\r\n    <Text class=\"modelData\" resizeTextForBestFit=\"true\" resizeTextMaxSize=\"30\" preferredWidth=\"500\" horizontalOverflow=\"Overflow\"  />\r\n    <Text class=\"modelDataTitle\" fontSize=\"30\" preferredWidth=\"500\" fontStyle=\"Bold\" horizontalOverflow=\"Overflow\" />\r\n    <Text class=\"modelDataName\" preferredWidth=\"500\" preferredHeight=\"30\" alignment=\"MiddleCenter\" fontStyle=\"Bold\" resizeTextForBestFit=\"true\" resizeTextMaxSize=\"30\" />\r\n    <VerticalScrollView scrollSensitivity=\"40\" />\r\n    <HorizontalScrollView scrollSensitivity=\"40\" />\r\n    <Button class=\"unassignedWeapon\" preferredHeight=\"24\" flexibleWidth=\"1\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"10\" resizeTextMaxSize=\"18\" />  <!--fontSize=\"18\"-->\r\n    <Button class=\"assignedWeapon\" preferredHeight=\"24\" flexibleWidth=\"1\" resizeTextForBestFit=\"true\" resizeTextMinSize=\"10\" resizeTextMaxSize=\"18\" colors=\"White|#fdb7c2|Red|White\" />\r\n    <Button class=\"assignAllButton\" preferredHeight=\"24\" fontSize=\"14\" preferredWidth=\"40\" />\r\n    <Button class=\"unassignAllButton\" preferredHeight=\"24\" fontSize=\"14\" preferredWidth=\"40\" colors=\"White|#fdb7c2|Red|White\" />\r\n    <HorizontalLayout class=\"groupingContainer\" childAlignment=\"UpperCenter\" spacing=\"10\" childForceExpandHeight=\"false\" childForceExpandWidth=\"false\" flexibleWidth=\"1\" />\r\n</Defaults>\r\n\r\n<Panel id=\"mainPanel\" class=\"mainWindow\" hideAnimation=\"FadeOut\" animationDuration=\"0.2\" active=\"false\">\r\n    <VerticalLayout id=\"loading\" class=\"panelContainer\" padding=\"70\" spacing=\"15\" visibility=\"hidden\" childForceExpandWidth=\"false\">\r\n        <Text id=\"loadingText\" fontSize=\"30\" fontStyle=\"Bold\">The Techpriests are currently chanting their hymns over your army list</Text>\r\n        <Text id=\"loadingText\" fontSize=\"30\" fontStyle=\"Bold\">please allow them to finish their sacred task</Text>\r\n        <!--<Text id=\"loadingDots\" fontSize=\"60\" fontStyle=\"Bold\"></Text>-->\r\n    </VerticalLayout>\r\n    <VerticalLayout id=\"welcomeWindow\" class=\"panelContainer\" padding=\"10 10 35 10\" spacing=\"20\" color=\"#e1e9a5\" active=\"false\" visibility=\"hidden\">\r\n        <VerticalLayout spacing=\"5\" childAlignment=\"LowerCenter\" height=\"200\" childForceExpandHeight=\"false\" childForceExpandWidth=\"false\">\r\n            <Text fontSize=\"40\" fontStyle=\"Bold\">Welcome to Yellowscribe v2!</Text>\r\n            <Text fontSize=\"20\">To get started, upload your Battlescribe Roster file to yellowscribe.xyz</Text>\r\n            <Text fontSize=\"20\" color=\"#FF0000\">Do NOT go to yellowscribe.net - that site is dead now!</Text>\r\n            <Text fontSize=\"20\">Then enter the code you received below:</Text>\r\n        </VerticalLayout>\r\n\r\n        <InputField id=\"armyInput\" onEndEdit=\"46ccee/updateArmyInputText\" lineType=\"SingleLine\" preferredHeight=\"103\" flexibleWidth=\"1\" fontSize=\"80\" color=\"White\" textAlignment=\"MiddleCenter\" placeholder=\"Copy and paste your code here!\" />\r\n        <Button preferredHeight=\"40\" preferredWidth=\"200\" color=\"Green\" textColor=\"White\" text=\"Submit\" fontSize=\"20\" fontStyle=\"Bold\" onClick=\"46ccee/moveToLoadingScreen()\" />\r\n    </VerticalLayout>\r\n    <Panel height=\"30\" width=\"30\" childForceExpandWidth=\"false\" ignoreLayout=\"true\" position=\"600 350 0\" pivot=\"1 1\">\r\n        <Panel rectAlignment=\"UpperRight\" height=\"30\" width=\"30\">\r\n            <Button color=\"Red\" textColor=\"White\" onClick=\"46ccee/closeWelcomeWindow\" fontStyle=\"Bold\">X</Button>\r\n        </Panel>\r\n    </Panel>\r\n    <VerticalLayout id=\"postLoading\" class=\"panelContainer\" visibility=\"hidden\">\r\n        <VerticalScrollView flexibleHeight=\"1\" flexibleWidth=\"1\" childForceExpandHeight=\"false\" color=\"#999999\">\r\n            <TableLayout id=\"loadedArmyContainer\" spacing=\"10\" childForceExpandHeight=\"false\" autoCalculateHeight=\"true\" cellSpacing=\"15\" color=\"#999999\" />\r\n        </VerticalScrollView>\r\n        <HorizontalLayout preferredHeight=\"45\">\r\n            <Button preferredHeight=\"40\" preferredWidth=\"200\" color=\"Green\" textColor=\"White\" text=\"Submit\" fontSize=\"20\" fontStyle=\"Bold\" onClick=\"46ccee/acceptEditedArmy()\" />\r\n        </HorizontalLayout>\r\n    </VerticalLayout>\r\n</Panel>\r\n<VerticalScrollView id=\"loadedScrollContainer\" scale=\"1.2 1.2 1.2\" width=\"2030\" height=\"3000\" active=\"false\" color=\"#ffffff00\" position=\"1545 0 -150\" verticalScrollbarVisibility=\"AutoHideAndExpandViewport\">\r\n    <VerticalLayout childForceExpandHeight=\"false\" spacing=\"60\" class=\"transparent\" flexibleWidth=\"1\" id=\"loadedContainer\" childForceExpandWidth=\"false\" childAlignment=\"MiddleCenter\" />\r\n</VerticalScrollView>",
      "JointFixed": {
        "ConnectedBodyGUID": "43ecc1",
        "EnableCollision": false,
        "Axis": {
          "x": 1.0,
          "y": 0.0,
          "z": 0.0
        },
        "Anchor": {
          "x": 0.0,
          "y": 0.0,
          "z": 0.0
        },
        "ConnectedAnchor": {
          "x": 1.00046718,
          "y": -1.29042128E-05,
          "z": -0.00316529721
        },
        "BreakForce": "Infinity",
        "BreakTorgue": "Infinity"
      }
    },
    {
      "GUID": "1bbe8d",
      "Name": "HandTrigger",
      "Transform": {
        "posX": -15.1107731,
        "posY": 4.81034231,
        "posZ": -20.1076221,
        "rotX": 0.0,
        "rotY": 0.0,
        "rotZ": 0.0,
        "scaleX": 11.7719851,
        "scaleY": 9.174497,
        "scaleZ": 4.871238
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.856,
        "g": 0.09999997,
        "b": 0.09399996,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Red",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "9a4e93",
      "Name": "HandTrigger",
      "Transform": {
        "posX": -30.2150211,
        "posY": 4.81034231,
        "posZ": 10.17524,
        "rotX": 0.0,
        "rotY": 90.0,
        "rotZ": 0.0,
        "scaleX": 11.6554289,
        "scaleY": 9.174497,
        "scaleZ": 4.91995144
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.905,
        "g": 0.898,
        "b": 0.171999961,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Yellow",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "f99102",
      "Name": "HandTrigger",
      "Transform": {
        "posX": 30.2511711,
        "posY": 4.81034231,
        "posZ": 9.59069252,
        "rotX": 0.0,
        "rotY": 270.0,
        "rotZ": 0.0,
        "scaleX": 11.6554213,
        "scaleY": 9.174497,
        "scaleZ": 4.91995144
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.627,
        "g": 0.124999978,
        "b": 0.941,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Purple",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "792f7b",
      "Name": "HandTrigger",
      "Transform": {
        "posX": 15.4749184,
        "posY": 4.81034231,
        "posZ": 19.8365288,
        "rotX": 0.0,
        "rotY": 179.8,
        "rotZ": 0.0,
        "scaleX": 11.7719746,
        "scaleY": 9.174497,
        "scaleZ": 4.87124
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.117999978,
        "g": 0.53,
        "b": 1.0,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Blue",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "e879d5",
      "Name": "HandTrigger",
      "Transform": {
        "posX": 15.1961212,
        "posY": 4.81034231,
        "posZ": -20.1400986,
        "rotX": 0.0,
        "rotY": 0.0,
        "rotZ": 0.0,
        "scaleX": 11.7719707,
        "scaleY": 9.174499,
        "scaleZ": 4.871238
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 1.0,
        "g": 1.0,
        "b": 1.0,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "White",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "b89482",
      "Name": "HandTrigger",
      "Transform": {
        "posX": -15.1927719,
        "posY": 4.81034231,
        "posZ": 19.787817,
        "rotX": 0.0,
        "rotY": 180.0,
        "rotZ": 0.0,
        "scaleX": 11.7719707,
        "scaleY": 9.174497,
        "scaleZ": 4.871238
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.191999972,
        "g": 0.701,
        "b": 0.167999953,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Green",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "fa7dda",
      "Name": "HandTrigger",
      "Transform": {
        "posX": 30.1035728,
        "posY": 4.81034231,
        "posZ": -8.449126,
        "rotX": 0.0,
        "rotY": 270.0,
        "rotZ": 0.0,
        "scaleX": 11.6554184,
        "scaleY": 9.174497,
        "scaleZ": 4.91995144
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.96,
        "g": 0.438999981,
        "b": 0.807,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Pink",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    },
    {
      "GUID": "b07a97",
      "Name": "HandTrigger",
      "Transform": {
        "posX": -30.247818,
        "posY": 4.81034231,
        "posZ": -8.822588,
        "rotX": 0.0,
        "rotY": 90.0,
        "rotZ": 0.0,
        "scaleX": 11.6554317,
        "scaleY": 9.174497,
        "scaleZ": 4.91995144
      },
      "Nickname": "",
      "Description": "",
      "GMNotes": "",
      "ColorDiffuse": {
        "r": 0.9559999,
        "g": 0.39199996,
        "b": 0.112999953,
        "a": 0.0
      },
      "LayoutGroupSortIndex": 0,
      "Value": 0,
      "Locked": true,
      "Grid": false,
      "Snap": true,
      "IgnoreFoW": false,
      "MeasureMovement": false,
      "DragSelectable": true,
      "Autoraise": true,
      "Sticky": true,
      "Tooltip": true,
      "GridProjection": false,
      "HideWhenFaceDown": false,
      "Hands": false,
      "FogColor": "Orange",
      "LuaScript": "",
      "LuaScriptState": "",
      "XmlUI": ""
    }
  ]
}